<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="app-title">Ultimate Marvel Universe Quiz - 10x Development Showcase</title>
    <meta name="description" content="A cutting-edge glassmorphic quiz application showcasing the Marvel Universe with advanced PWA features, real-time API integration, and 10x programming capabilities">
    <!-- Cross-browser theme color support -->    
    <meta name="theme-color" content="#e94560">
    <meta name="msapplication-navbutton-color" content="#e94560">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Ultimate Marvel Quiz">
    <meta name="keywords" content="Marvel, Quiz, PWA, Glassmorphism, 10x Development, API Integration">
    <meta name="author" content="StrayDog Syndications - 10x Developer">

    <!-- Enhanced Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://gateway.marvel.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: http: blob:; connect-src 'self' https://gateway.marvel.com https://api.marvel.com; font-src 'self' data:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=()">
    <meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains; preload">

    <!-- PWA Configuration -->
    <link rel="icon" href="./assets/icons/favicon.svg" type="image/svg+xml">
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="./assets/icons/icon-192x192.png">

    <!-- Preload Critical Resources -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" as="script">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Font Loading with Fallback -->
    <style>
        /* Font Face Declarations with Local Fallbacks */
        @font-face {
            font-family: 'Inter-Fallback';
            src: local('Inter'), local('Inter-Regular'),
                 url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        
        /* Robust Font Stack */
        :root {
            --font-primary: 'Inter', 'Inter-Fallback', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            --font-display: 'Inter', 'Inter-Fallback', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        }
        
        /* Font Loading Detection */
        .font-loading {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        }
        
        .font-loaded {
            font-family: var(--font-primary);
        }
    </style>
    
    <!-- Async Font Loading with Error Handling -->
    <script>
        (function() {
            // Font loading with timeout and fallback
            const fontTimeout = 3000; // 3 seconds timeout
            let fontLoaded = false;
            
            // Show loading indicator initially
            document.addEventListener('DOMContentLoaded', function() {
                const indicator = document.getElementById('fontLoadingIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            });
            
            // Create font link element
            const fontLink = document.createElement('link');
            fontLink.rel = 'stylesheet';
            fontLink.href = 'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap';
            
            // Font loading success handler
             fontLink.onload = function() {
                 fontLoaded = true;
                 document.documentElement.classList.add('font-loaded');
                 document.documentElement.classList.remove('font-loading');
                 console.log('âœ… Inter font loaded successfully');
                 
                 // Hide loading indicator
                 const indicator = document.getElementById('fontLoadingIndicator');
                 if (indicator) {
                     indicator.classList.remove('show');
                     setTimeout(() => {
                         if (indicator.parentNode) {
                             indicator.parentNode.removeChild(indicator);
                         }
                     }, 300);
                 }
             };
             
             // Font loading error handler
             fontLink.onerror = function() {
                 console.warn('âš ï¸ Failed to load Inter font, using system fallbacks');
                 document.documentElement.classList.add('font-loaded');
                 document.documentElement.classList.remove('font-loading');
                 
                 // Update and hide loading indicator
                 const indicator = document.getElementById('fontLoadingIndicator');
                 if (indicator) {
                     const textElement = indicator.querySelector('.font-loading-text');
                     if (textElement) {
                         textElement.textContent = 'âš ï¸ Using fallback fonts';
                     }
                     setTimeout(() => {
                         indicator.classList.remove('show');
                         setTimeout(() => {
                             if (indicator.parentNode) {
                                 indicator.parentNode.removeChild(indicator);
                             }
                         }, 300);
                     }, 1500);
                 }
             };
             
             // Timeout fallback
             setTimeout(function() {
                 if (!fontLoaded) {
                     console.warn('âš ï¸ Font loading timeout, using system fallbacks');
                     document.documentElement.classList.add('font-loaded');
                     document.documentElement.classList.remove('font-loading');
                     
                     // Update and hide loading indicator
                     const indicator = document.getElementById('fontLoadingIndicator');
                     if (indicator) {
                         const textElement = indicator.querySelector('.font-loading-text');
                         if (textElement) {
                             textElement.textContent = 'âš ï¸ Font timeout - using fallbacks';
                         }
                         setTimeout(() => {
                             indicator.classList.remove('show');
                             setTimeout(() => {
                                 if (indicator.parentNode) {
                                     indicator.parentNode.removeChild(indicator);
                                 }
                             }, 300);
                         }, 1500);
                     }
                 }
             }, fontTimeout);
            
            // Add loading class initially
            document.documentElement.classList.add('font-loading');
            
            // Append font link to head
            document.head.appendChild(fontLink);
        })();
    </script>
    
    <!-- External CSS Files -->
    <link rel="stylesheet" href="assets/css/fonts.css">
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/glassmorphism.css">
    <link rel="stylesheet" href="assets/css/responsive.css">

    <style>
        /* CSS Custom Properties for Dynamic Theming */
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            --secondary-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --accent-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.9);
            --text-muted: rgba(255, 255, 255, 0.75);
            --success-color: #4caf50;
            --error-color: #f44336;
            --warning-color: #ff9800;
            --info-color: #2196f3;
            --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 12px 40px rgba(0, 0, 0, 0.15);
            --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.3);
            --border-radius-sm: 8px;
            --border-radius-md: 15px;
            --border-radius-lg: 25px;
            --transition-fast: 0.2s ease;
            --transition-medium: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-primary);
            background: var(--primary-gradient);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            color: var(--text-primary);
            line-height: 1.7;
            font-size: 16px;
            font-weight: 400;
            /* Performance optimizations */
            will-change: auto;
            transform: translateZ(0);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            -webkit-tap-highlight-color: transparent;
            font-display: swap;
        }

        /* Cosmic Background Animation */
        .cosmic-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: var(--primary-gradient);
        }

        .cosmic-background::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%);
            animation: cosmicShift 20s ease-in-out infinite;
        }

        @keyframes cosmicShift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }

        /* GPU Acceleration for Performance */
        .app-container,
        .screen,
        .particle,
        .answer-option,
        .character-frame,
        .stat-card,
        .glass-card {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Optimize animations for 60fps */
        @media (prefers-reduced-motion: no-preference) {
            .particle {
                animation-timing-function: linear;
                will-change: transform;
            }

            .answer-option:hover,
            .character-frame:hover,
            .stat-card:hover {
                will-change: transform;
            }
        }

        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* Particle System */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            contain: layout style paint;
        }

        .particle {
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            contain: layout style paint;
        }

        .particle:nth-child(odd) {
            animation-direction: reverse;
        }

        .particle:nth-child(3n) {
            background: rgba(103, 126, 234, 0.4);
            animation-duration: 8s;
        }

        .particle:nth-child(5n) {
            background: rgba(250, 112, 154, 0.4);
            animation-duration: 10s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px) translateX(0px) scale(1);
                opacity: 0.7;
            }
            25% {
                transform: translateY(-20px) translateX(10px) scale(1.1);
                opacity: 1;
            }
            50% {
                transform: translateY(-10px) translateX(-10px) scale(0.9);
                opacity: 0.8;
            }
            75% {
                transform: translateY(-30px) translateX(5px) scale(1.05);
                opacity: 0.9;
            }
        }

        /* Main Container */
        .app-container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        /* Glassmorphic Card */
        .glass-card {
            background: var(--glass-bg);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 255, 255, 0.1);
            padding: 2.5rem;
            max-width: 900px;
            width: 100%;
            position: relative;
            overflow: hidden;
            animation: slideInUp 0.8s var(--transition-medium);
            transform-style: preserve-3d;
            transform: perspective(1000px) translateZ(0);
            transition: all var(--transition-medium);
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Typography */
        .app-title {
            font-size: clamp(2.2rem, 5vw, 4rem);
            font-weight: 900;
            text-align: center;
            margin-bottom: 1.2rem;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #fff 0%, #f093fb 50%, #f5f7fa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .app-subtitle {
            text-align: center;
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2.2rem;
            font-weight: 400;
            letter-spacing: 0.01em;
            line-height: 1.5;
            max-width: 85%;
            margin-left: auto;
            margin-right: auto;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }

        /* Game Stats Dashboard */
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all var(--transition-medium);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            transform-style: preserve-3d;
            transform: perspective(1000px) translateZ(0);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .stat-card:hover::before {
            left: 100%;
        }

        .stat-card:hover {
            transform: perspective(1000px) translateY(-5px) translateZ(10px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1), 0 0 15px rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-weight: 500;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--text-primary);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            letter-spacing: -0.01em;
        }

        /* Question Container */
        .question-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--border-radius-md);
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .question-number {
            font-size: 0.9rem;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius-lg);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .difficulty-badge {
            padding: 0.6rem 1.4rem;
            border-radius: var(--border-radius-lg);
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            display: inline-block;
            margin: 0.5rem 0;
        }

        .difficulty-easy {
            background: linear-gradient(135deg, var(--success-color), #66bb6a);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .difficulty-medium {
            background: linear-gradient(135deg, var(--warning-color), #ffb74d);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .difficulty-hard {
            background: linear-gradient(135deg, var(--error-color), #ef5350);
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Character Image System */
        .character-showcase {
            display: flex;
            justify-content: center;
            margin: 1rem 0 2rem;
            max-width: 100%;
            overflow: hidden;
        }

        .character-frame {
            position: relative;
            width: 200px;
            height: 200px;
            border-radius: var(--border-radius-md);
            overflow: hidden;
            box-shadow: var(--shadow-heavy);
            transition: all var(--transition-medium);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        }

        .character-frame:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.4);
        }

        .character-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all var(--transition-medium);
        }

        .character-frame:hover .character-image {
            transform: scale(1.1);
        }

        .character-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 1rem;
            transform: translateY(100%);
            transition: transform var(--transition-medium);
        }

        .character-frame:hover .character-overlay {
            transform: translateY(0);
        }

        .character-name {
            font-weight: 700;
            margin-bottom: 0.3rem;
            letter-spacing: 0.01em;
            font-size: 1.1rem;
        }

        .character-tier {
            font-size: 0.85rem;
            opacity: 0.9;
            letter-spacing: 0.02em;
        }

        /* Loading States */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            background: linear-gradient(135deg, rgba(103, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: var(--border-radius-md);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Question Text */
        .question-text {
            font-size: 1.5rem;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 2.2rem;
            text-align: center;
            font-weight: 600;
            letter-spacing: 0.01em;
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }

        /* Answer Grid */
        .answers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .answer-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-md);
            padding: 1.6rem;
            cursor: pointer;
            transition: all var(--transition-medium);
            position: relative;
            overflow: hidden;
            text-align: left;
            font-size: 1.05rem;
            line-height: 1.5;
            font-weight: 500;
            color: var(--text-primary);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            letter-spacing: 0.01em;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            transform-style: preserve-3d;
            transform: perspective(1000px) translateZ(0);
        }

        .answer-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .answer-option:hover::before {
            left: 100%;
        }

        .answer-option:hover {
            transform: perspective(1000px) translateY(-3px) translateZ(10px);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1), 0 0 15px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .answer-option.selected {
            border-color: var(--info-color);
            background: rgba(33, 150, 243, 0.2);
            transform: perspective(1000px) translateY(-3px) translateZ(5px);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.3), 0 4px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
        }

        .answer-option.correct {
            border-color: var(--success-color);
            background: rgba(76, 175, 80, 0.2);
            animation: correctPulse 0.6s ease;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4), 0 4px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .answer-option.incorrect {
            border-color: var(--error-color);
            background: rgba(244, 67, 54, 0.2);
            animation: incorrectShake 0.6s ease;
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.4), 0 4px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 8px rgba(244, 67, 54, 0.5);
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Timer System */
        .timer-container {
            margin-bottom: 2rem;
        }

        .timer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .timer-label {
            font-size: 0.95rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
        }

        .timer-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .timer-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), var(--warning-color), var(--error-color));
            transition: width 0.1s linear;
            border-radius: 4px;
            position: relative;
        }

        .timer-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: timerShimmer 2s ease-in-out infinite;
        }

        @keyframes timerShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Control Buttons */
        .control-panel {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: var(--text-primary);
            padding: 1rem 2rem;
            border-radius: var(--border-radius-lg);
            cursor: pointer;
            font-size: 1.05rem;
            font-weight: 700;
            transition: all var(--transition-medium);
            position: relative;
            overflow: hidden;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            transform-style: preserve-3d;
            transform: perspective(1000px) translateZ(0);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: perspective(1000px) translateY(-3px) translateZ(10px);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 7px 14px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1), 0 0 15px rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7), 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: perspective(1000px) translateY(-1px) translateZ(5px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.1s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--info-color), #42a5f5);
            border-color: var(--info-color);
            box-shadow: 0 4px 15px rgba(66, 165, 245, 0.4), 0 1px 3px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 5px rgba(255, 255, 255, 0.5);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color), #66bb6a);
            border-color: var(--success-color);
            box-shadow: 0 4px 15px rgba(102, 187, 106, 0.4), 0 1px 3px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 5px rgba(255, 255, 255, 0.5);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error-color), #ef5350);
            border-color: var(--error-color);
            box-shadow: 0 4px 15px rgba(239, 83, 80, 0.4), 0 1px 3px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 5px rgba(255, 255, 255, 0.5);
            color: white;
        }

        /* Screen Management */
        .screen {
            display: none;
            animation: fadeInScale 0.5s var(--transition-medium);
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Difficulty Selection */
        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .difficulty-option {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-md);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-medium);
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
            transform-style: preserve-3d;
            transform: perspective(1000px) translateZ(0);
        }

        .difficulty-option:hover {
            transform: perspective(1000px) translateY(-5px) translateZ(10px);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1), 0 0 15px rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }

        .difficulty-option.selected {
            border-color: var(--info-color);
            background: rgba(33, 150, 243, 0.1);
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.3), 0 4px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
            transform: perspective(1000px) translateZ(5px);
        }

        .difficulty-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .difficulty-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Results Screen */
        .results-container {
            text-align: center;
        }

        .results-score {
            font-size: 4rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        .results-message {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: var(--text-secondary);
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .glass-card {
                padding: 1.5rem;
                margin: 10px;
            }

            .app-title {
                font-size: 2rem;
            }

            .stats-dashboard {
                grid-template-columns: repeat(2, 1fr);
            }

            .answers-grid {
                grid-template-columns: 1fr;
            }

            .character-frame {
                width: 150px;
                height: 150px;
            }

            .control-panel {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .glass-card {
                padding: 1rem;
            }

            .stats-dashboard {
                grid-template-columns: 1fr;
            }

            .question-header {
                flex-direction: column;
                gap: 1rem;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High Contrast Mode */
        @media (prefers-contrast: high) {
            :root {
                --glass-bg: rgba(0, 0, 0, 0.8);
                --glass-border: rgba(255, 255, 255, 0.8);
                --text-primary: #ffffff;
                --text-secondary: #ffffff;
            }
        }

        /* Enhanced Focus Styles for WCAG 2.1 Compliance */
        .btn:focus,
        .answer-option:focus,
        .difficulty-option:focus,
        .install-prompt:focus {
            outline: 3px solid var(--info-color);
            outline-offset: 2px;
            box-shadow: 0 0 0 6px rgba(56, 189, 248, 0.3);
        }

        /* Focus visible for keyboard navigation */
        .btn:focus-visible,
        .answer-option:focus-visible,
        .difficulty-option:focus-visible {
            outline: 3px solid var(--warning-color);
            outline-offset: 3px;
            box-shadow: 0 0 0 8px rgba(251, 191, 36, 0.4);
        }

        /* Skip link for screen readers */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--primary-color);
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 10000;
            font-weight: 600;
        }

        .skip-link:focus {
            top: 6px;
        }

        /* High contrast mode enhancements */
        @media (prefers-contrast: high) {
            .btn, .answer-option, .difficulty-option {
                border: 2px solid currentColor;
            }

            .glass-card {
                background: rgba(0, 0, 0, 0.9);
                border: 2px solid rgba(255, 255, 255, 0.9);
            }
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Keyboard navigation indicators */
        .keyboard-user .btn:focus,
        .keyboard-user .answer-option:focus,
        .keyboard-user .difficulty-option:focus {
            transform: scale(1.05);
            transition: transform 0.2s ease;
        }

        /* Install Button */
        .install-prompt {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(233, 69, 96, 0.95);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--border-radius-lg);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-medium);
            transition: all var(--transition-medium);
            z-index: 1000;
            display: none;
        }

        .install-prompt:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy);
        }

        .install-prompt.show {
            display: block;
            animation: slideInRight 0.5s var(--transition-medium);
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.95);
            color: white;
            padding: 15px 25px;
            border-radius: var(--border-radius-lg);
            font-size: 14px;
            font-weight: 600;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-medium);
            z-index: 1001;
            animation: slideDown 0.3s ease;
            display: none;
        }

        .notification.show {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Performance Optimizations */
        .character-image,
        .particle {
            will-change: transform;
        }

        .timer-fill {
            will-change: width;
        }

        /* Achievement Notification Styles */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: -400px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            min-width: 300px;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3), 0 0 50px rgba(255, 215, 0, 0.1);
            z-index: 10000;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: translateX(0);
        }

        .achievement-notification.show {
            right: 20px;
            animation: achievementPulse 2s ease-in-out;
        }

        .achievement-icon {
            font-size: 2.5rem;
            animation: achievementSpin 1s ease-in-out;
        }

        .achievement-content {
            flex: 1;
        }

        .achievement-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .achievement-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: #000;
            margin-bottom: 3px;
        }

        .achievement-bonus {
            font-size: 1rem;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.7);
        }

        @keyframes achievementPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes achievementSpin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        /* Score breakdown display */
        .score-breakdown {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9rem;
        }

        .score-item.total {
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 10px;
            margin-top: 10px;
            font-weight: 700;
            font-size: 1.1rem;
        }

        .combo-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
            transform: scale(0);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .combo-indicator.show {
            transform: scale(1);
            animation: comboPulse 0.6s ease-in-out;
        }

        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Achievement and Performance Styles */
        .achievements-summary {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        .achievements-summary h4 {
            margin: 0 0 10px 0;
            color: #ffd700;
            font-size: 1.1em;
        }

        .achievement-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #1a1a2e;
            padding: 5px 12px;
            margin: 3px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .performance-breakdown {
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 123, 255, 0.1);
            border: 1px solid rgba(0, 123, 255, 0.3);
            border-radius: 10px;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        .performance-breakdown h4 {
            margin: 0 0 10px 0;
            color: #007bff;
            font-size: 1.1em;
        }

        /* Classes for difficulty levels */
        .difficulty-easy {
            color: var(--success-color);
        }

        .difficulty-medium {
            color: var(--warning-color);
        }

        .difficulty-hard {
            color: var(--error-color);
        }

        /* Class for timer fill */
        .timer-fill-full {
            width: 100%;
        }

        /* Class for hidden elements */
        .hidden {
            display: none;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .stat-grid > div {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            text-align: center;
            font-size: 0.9em;
        }

        .stat-grid strong {
            color: #00ff88;
        }

        /* Print Styles */
        @media print {
            .cosmic-background,
            .particles,
            .install-prompt,
            .notification,
            .achievement-notification,
            .combo-indicator,
            .achievements-summary,
            .performance-breakdown,
            .score-breakdown {
                display: none !important;
            }

            .glass-card {
                background: white;
                color: black;
                box-shadow: none;
                border: 1px solid #ccc;
            }
        }
    </style>
</head>
<body>
    <!-- Font Loading Indicator -->
    <div id="fontLoadingIndicator" class="font-loading-indicator" aria-live="polite" role="status">
        <div class="font-loading-spinner"></div>
        <span class="font-loading-text">Loading fonts...</span>
    </div>

    <!-- Skip link for screen readers -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Cosmic Background -->
    <div class="cosmic-background" aria-hidden="true"></div>

    <!-- Particle System -->
    <div class="particles" id="particles" aria-hidden="true" role="presentation"></div>

    <!-- PWA Install Prompt -->
    <button class="install-prompt" id="installPrompt" aria-label="Install Marvel Quiz App as a Progressive Web App">
        ðŸ“± <span class="sr-only">Install</span>Install App
    </button>

    <!-- Notification System -->
    <div class="notification" id="notification" role="alert" aria-live="polite" aria-atomic="true"></div>

    <!-- Keyboard navigation detection -->
    <script>
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                document.body.classList.add('keyboard-user');
            }
        });

        document.addEventListener('mousedown', function() {
            document.body.classList.remove('keyboard-user');
        });
    </script>

    <!-- Main Application -->
    <main class="app-container" id="main-content" role="main">
        <div class="glass-card">
            <!-- Start Screen -->
            <section class="screen active" id="startScreen" aria-labelledby="app-title" role="region">
                <header>
                    <h1 class="app-title" id="app-title">Ultimate Marvel Universe Quiz</h1>
                    <p class="app-subtitle">Test your knowledge of the Marvel Universe with this cutting-edge quiz experience</p>
                </header>

                <fieldset class="difficulty-grid" aria-labelledby="difficulty-legend">
                    <legend id="difficulty-legend" class="sr-only">Choose your difficulty level</legend>
                    <div class="difficulty-option" data-difficulty="easy" tabindex="0" role="button"
                         aria-label="Easy difficulty: Perfect for newcomers to the Marvel Universe"
                         aria-describedby="easy-desc">
                        <div class="difficulty-title difficulty-easy">Easy</div>
                        <div class="difficulty-description" id="easy-desc">Perfect for newcomers to the Marvel Universe</div>
                    </div>
                    <div class="difficulty-option" data-difficulty="medium" tabindex="0" role="button"
                         aria-label="Medium difficulty: For true Marvel fans with solid knowledge"
                         aria-describedby="medium-desc">
                        <div class="difficulty-title difficulty-medium">Medium</div>
                        <div class="difficulty-description" id="medium-desc">For true Marvel fans with solid knowledge</div>
                    </div>
                    <div class="difficulty-option" data-difficulty="hard" tabindex="0" role="button"
                         aria-label="Hard difficulty: Ultimate challenge for Marvel experts"
                         aria-describedby="hard-desc">
                        <div class="difficulty-title difficulty-hard">Hard</div>
                        <div class="difficulty-description" id="hard-desc">Ultimate challenge for Marvel experts</div>
                    </div>
                </fieldset>

                <div class="control-panel" role="group" aria-label="Quiz controls">
                    <button class="btn btn-primary" onclick="startQuiz()" id="startButton" disabled
                            aria-describedby="start-help">
                        ðŸš€ <span class="sr-only">Start</span>Start Quiz
                    </button>
                    <div id="start-help" class="sr-only">Select a difficulty level to enable the start button</div>
                </div>
            </section>

            <!-- Game Screen -->
            <section class="screen" id="gameScreen" aria-labelledby="game-title" role="region">
                <h2 id="game-title" class="sr-only">Quiz Game in Progress</h2>

                <!-- Combo Indicator -->
                <div class="combo-indicator" id="comboIndicator" aria-live="polite" aria-atomic="true" role="status">
                    ðŸ”¥ <span class="sr-only">Combo multiplier:</span>COMBO x<span id="comboCount" aria-label="Current combo count">0</span>
                </div>
                
                <!-- Character Showcase -->
                <div class="character-showcase" id="characterShowcase" role="img" aria-labelledby="character-description">
                    <div class="loading-container" id="characterLoading" aria-live="polite">
                        <div class="loading-spinner" aria-hidden="true"></div>
                        <div class="loading-text">Loading Marvel character...</div>
                    </div>
                    <div id="character-description" class="sr-only">Character image will appear here</div>
                </div>

                <!-- Stats Dashboard -->
                <div class="stats-dashboard" role="group" aria-label="Game statistics">
                    <div class="stat-card">
                        <div class="stat-label" id="question-label">Question</div>
                        <div class="stat-value" id="questionCounter" aria-labelledby="question-label" aria-live="polite">1/10</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label" id="score-label">Score</div>
                        <div class="stat-value" id="currentScore" aria-labelledby="score-label" aria-live="polite">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label" id="streak-label">Streak</div>
                        <div class="stat-value" id="currentStreak" aria-labelledby="streak-label" aria-live="polite">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label" id="bonus-label">Bonus</div>
                        <div class="stat-value" id="bonusPoints" aria-labelledby="bonus-label" aria-live="polite">0</div>
                    </div>
                </div>

                <!-- Timer -->
                <div class="timer-container" role="timer" aria-label="Question timer">
                    <div class="timer-header">
                        <span class="timer-label">Time Remaining</span>
                        <span class="timer-value" id="timerValue" aria-live="polite" aria-atomic="true">30s</span>
                    </div>
                    <div class="timer-bar" role="progressbar" aria-valuemin="0" aria-valuemax="30" aria-valuenow="30" aria-label="Time remaining progress">
                        <div class="timer-fill timer-fill-full" id="timerFill"></div>
                    </div>
                </div>

                <!-- Question Container -->
                <div class="question-container" role="group" aria-labelledby="question-header">
                    <div class="question-header" id="question-header">
                        <div class="question-number" id="questionNumber" aria-live="polite">Question 1 of 10</div>
                        <div class="difficulty-badge" id="difficultyBadge" role="status" aria-label="Current difficulty level">Medium</div>
                    </div>

                    <!-- Character Showcase moved to top of game interface -->

                    <div class="question-text" id="questionText" role="heading" aria-level="3" aria-live="polite">Loading question...</div>

                    <div class="answers-grid" id="answersGrid" role="group" aria-labelledby="answers-label">
                        <div id="answers-label" class="sr-only">Answer options</div>
                        <!-- Answers will be dynamically generated -->
                    </div>
                </div>

                <div class="control-panel" role="group" aria-label="Question navigation">
                    <button class="btn hidden" onclick="nextQuestion()" id="nextButton"
                            aria-describedby="next-help">
                        âž¡ï¸ <span class="sr-only">Next</span>Next Question
                    </button>
                    <div id="next-help" class="sr-only">Proceed to the next question</div>
                </div>
            </section>

            <!-- Results Screen -->
            <section class="screen" id="resultsScreen" aria-labelledby="results-title" role="region">
                <div class="results-container">
                    <header>
                        <h2 class="app-title" id="results-title">Quiz Complete!</h2>

                        <div class="results-score" id="finalScore" aria-live="polite" role="status">0/10</div>
                        <div class="results-message" id="resultsMessage" aria-live="polite">Great job, True Believer!</div>
                    </header>

                    <div class="results-stats" role="group" aria-label="Quiz results summary">
                        <div class="stat-card">
                            <div class="stat-label" id="correct-label">Correct Answers</div>
                            <div class="stat-value" id="correctAnswers" aria-labelledby="correct-label">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label" id="accuracy-label">Accuracy</div>
                            <div class="stat-value" id="accuracyPercent" aria-labelledby="accuracy-label">0%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label" id="time-label">Time Taken</div>
                            <div class="stat-value" id="totalTime" aria-labelledby="time-label">0:00</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label" id="final-score-label">Final Score</div>
                            <div class="stat-value" id="totalPoints" aria-labelledby="final-score-label">0</div>
                        </div>
                    </div>

                    <div class="control-panel" role="group" aria-label="Quiz actions">
                        <button class="btn btn-success" onclick="restartQuiz()"
                                aria-describedby="restart-help">
                            ðŸ”„ <span class="sr-only">Restart</span>Play Again
                        </button>
                        <button class="btn" onclick="goHome()"
                                aria-describedby="home-help">
                            ðŸ  <span class="sr-only">Go to</span>Home
                        </button>
                        <div id="restart-help" class="sr-only">Start a new quiz with the same difficulty</div>
                        <div id="home-help" class="sr-only">Return to the main menu</div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <!-- GitHub Deployment Badge -->
    <div class="github-deployment-badge" id="githubBadge" role="complementary" aria-label="GitHub deployment information">
        <div class="badge-icon" aria-hidden="true">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.374 0 0 5.373 0 12 0 17.302 3.438 21.8 8.207 23.387c.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/>
            </svg>
        </div>
        <div class="badge-content">
            <div class="badge-title">GitHub Demo</div>
            <div class="badge-description">Limited API functionality due to deployment restrictions</div>
        </div>
        <div class="badge-close" onclick="hideBadge()" role="button" tabindex="0" aria-label="Close badge" onkeydown="if(event.key==='Enter'||event.key===' ')hideBadge()">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
        </div>
    </div>

    <!-- External Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Configuration System -->
    <script src="./config.js"></script>
    
    <!-- Environment Variables Loader -->
    <script src="./env-loader.js?v=2"></script>

    <script>
        // Application State
        let gameState = {
            currentQuestion: 0,
            score: 0,
            streak: 0,
            maxStreak: 0,
            totalPoints: 0,
            difficulty: 'medium',
            questions: [],
            startTime: null,
            questionStartTime: null,
            timeLeft: 30,
            timer: null,
            isAnswered: false
        };

        // ===== API & DATA HANDLING =====
        // Functions for interacting with external APIs and managing data
        
        // Advanced Marvel API Configuration with Smart Caching & Rate Limiting
        const MARVEL_API = {
            baseUrl: 'https://gateway.marvel.com/v1/public',
            publicKey: localStorage.getItem('marvel_public_key') || window.ENV?.VITE_MARVEL_PUBLIC_KEY || 'your_public_key_here',
            privateKey: localStorage.getItem('marvel_private_key') || window.ENV?.MARVEL_PRIVATE_KEY || 'your_private_key_here',

            // Configuration
            config: {
                timeout: parseInt(window.ENV?.VITE_API_TIMEOUT) || 10000,
                maxRetries: parseInt(window.ENV?.VITE_MAX_RETRIES) || 3,
                rateLimitDelay: 1000,
                cacheTimeout: parseInt(window.ENV?.VITE_MARVEL_CACHE_DURATION) || 3600000, // 1 hour
                maxCacheSize: 100
            },

            // Cache and rate limiting
            cache: new Map(),
            requestQueue: [],
            isProcessingQueue: false,
            lastRequestTime: 0,

            // Initialize API with environment variables
            init() {
                // Try to load from environment or localStorage
                const envPublicKey = window.ENV?.VITE_MARVEL_PUBLIC_KEY;
                const envPrivateKey = window.ENV?.MARVEL_PRIVATE_KEY;

                if (envPublicKey) this.publicKey = envPublicKey;
                if (envPrivateKey) this.privateKey = envPrivateKey;

                // Check if keys are placeholders and show warning
                if (this.publicKey === 'your_public_key_here' || this.privateKey === 'your_private_key_here') {
                    console.warn('âš ï¸ Marvel API keys are using placeholder values. Please set valid API keys.');
                    showNotification('âš ï¸ Marvel API keys not configured - using offline mode', 5000);
                }

                console.log('ðŸ”‘ Marvel API initialized with keys:', {
                    publicKey: this.publicKey.substring(0, 8) + '...',
                    hasPrivateKey: !!this.privateKey
                });
            },

            // Generate secure authentication parameters
            async getAuthParams() {
                const timestamp = Date.now();
                let hash;

                try {
                    // Use Web Crypto API for secure hashing if available
                    if (window.crypto && window.crypto.subtle) {
                        const message = timestamp + this.privateKey + this.publicKey;
                        const msgBuffer = new TextEncoder().encode(message);
                        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    } else if (typeof CryptoJS !== 'undefined') {
                        // Fallback to CryptoJS if available
                        hash = CryptoJS.MD5(timestamp + this.privateKey + this.publicKey).toString();
                    } else {
                        // Simple fallback for demo
                        hash = 'demo_hash_' + timestamp;
                        console.warn('âš ï¸ Using demo hash - add CryptoJS for production');
                    }
                } catch (error) {
                    console.error('âŒ Hash generation failed:', error);
                    hash = 'fallback_hash_' + timestamp;
                }

                return {
                    ts: timestamp,
                    apikey: this.publicKey,
                    hash: hash
                };
            },

            // Smart caching system
            getCacheKey(endpoint, params) {
                const sortedParams = Object.keys(params).sort().reduce((result, key) => {
                    result[key] = params[key];
                    return result;
                }, {});
                return `${endpoint}_${JSON.stringify(sortedParams)}`;
            },

            setCache(key, data) {
                // Implement LRU cache
                if (this.cache.size >= this.config.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                this.cache.set(key, {
                    data: data,
                    timestamp: Date.now(),
                    hits: 0
                });
            },

            getCache(key) {
                const cached = this.cache.get(key);
                if (!cached) return null;

                // Check if cache is expired
                if (Date.now() - cached.timestamp > this.config.cacheTimeout) {
                    this.cache.delete(key);
                    return null;
                }

                // Update hit count for LRU
                cached.hits++;
                console.log('ðŸ“¦ Cache hit for:', key);
                return cached.data;
            },

            // Rate limiting with queue
            async queueRequest(requestFn) {
                return new Promise((resolve, reject) => {
                    this.requestQueue.push({ requestFn, resolve, reject });
                    this.processQueue();
                });
            },

            async processQueue() {
                if (this.isProcessingQueue || this.requestQueue.length === 0) return;

                this.isProcessingQueue = true;

                while (this.requestQueue.length > 0) {
                    const timeSinceLastRequest = Date.now() - this.lastRequestTime;

                    if (timeSinceLastRequest < this.config.rateLimitDelay) {
                        await new Promise(resolve =>
                            setTimeout(resolve, this.config.rateLimitDelay - timeSinceLastRequest)
                        );
                    }

                    const { requestFn, resolve, reject } = this.requestQueue.shift();

                    try {
                        this.lastRequestTime = Date.now();
                        const result = await requestFn();
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                }

                this.isProcessingQueue = false;
            },

            // Enhanced fetch with retry logic
            async fetchWithRetry(url, options = {}, retryCount = 0) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json',
                            'User-Agent': 'Ultimate-Marvel-Quiz/2.0.0',
                            'Cache-Control': 'max-age=300',
                            ...options.headers
                        }
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return response;

                } catch (error) {
                    clearTimeout(timeoutId);

                    if (retryCount < this.config.maxRetries && error.name !== 'AbortError') {
                        console.log(`ðŸ”„ Retrying request (${retryCount + 1}/${this.config.maxRetries})...`);
                        await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1)));
                        return this.fetchWithRetry(url, options, retryCount + 1);
                    }

                    throw error;
                }
            },

            // Make authenticated API call with progressive enhancement
            async call(endpoint, params = {}) {
                // Check if Marvel Quiz is enabled from environment variables
                if (window.ENV?.VITE_MARVEL_QUIZ_ENABLED !== 'true') {
                    throw new Error('Marvel Quiz API integration is disabled in environment settings');
                }

                const cacheKey = this.getCacheKey(endpoint, params);

                // Check cache first
                const cachedData = this.getCache(cacheKey);
                if (cachedData) return cachedData;

                // Determine environment and use appropriate API method
                const isProd = window.CONFIG?.isProd || (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1');
                const isGitHubPages = window.location.hostname.includes('github.io');

                if (isProd && isGitHubPages) {
                    // Production GitHub Pages: Use serverless function proxy
                    return this.callViaServerless(endpoint, params, cacheKey);
                } else {
                    // Development or other production: Direct API calls
                    return this.callDirect(endpoint, params, cacheKey);
                }
            },

            // Direct API call method (for development)
            async callDirect(endpoint, params = {}, cacheKey) {
                return this.queueRequest(async () => {
                    try {
                        // Check if API keys are valid before making request
                        if (this.publicKey === 'your_public_key_here' || this.privateKey === 'your_private_key_here') {
                            throw new Error('Invalid API keys. Please configure valid Marvel API keys.');
                        }

                        const authParams = await this.getAuthParams();
                        const url = new URL(`${this.baseUrl}${endpoint}`);

                        // Add auth and custom parameters
                        Object.entries({...authParams, ...params}).forEach(([key, value]) => {
                            url.searchParams.append(key, value);
                        });

                        console.log('ðŸŒ Marvel API direct request:', endpoint, params);
                        const response = await this.fetchWithRetry(url);
                        const data = await response.json();

                        if (data.code !== 200) {
                            const errorDetails = data.status || data.message || JSON.stringify(data);
                            throw new Error(`Marvel API Error: ${errorDetails}`);
                        }

                        // Cache successful response
                        this.setCache(cacheKey, data);

                        console.log('âœ… Marvel API direct success:', {
                            endpoint,
                            results: data.data?.results?.length || 0,
                            total: data.data?.total || 0
                        });

                        return data;

                    } catch (error) {
                        console.error('âŒ Marvel API Direct Error:', error);
                        throw error;
                    }
                });
            },

            // Serverless function API call method (for production)
            async callViaServerless(endpoint, params = {}, cacheKey) {
                return this.queueRequest(async () => {
                    try {
                        // Use serverless function proxy for production
                        const serverlessUrl = window.CONFIG?.getApiEndpoint() || 'https://your-app.netlify.app/.netlify/functions/marvel-api';
                        
                        console.log('ðŸŒ Marvel API serverless request:', endpoint, params);
                        
                        const response = await this.fetchWithRetry(serverlessUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                endpoint,
                                params
                            })
                        });

                        const data = await response.json();

                        if (data.error) {
                            throw new Error(`Serverless API Error: ${data.error}`);
                        }

                        if (data.code !== 200) {
                            const errorDetails = data.status || data.message || JSON.stringify(data);
                            throw new Error(`Marvel API Error: ${errorDetails}`);
                        }

                        // Cache successful response
                        this.setCache(cacheKey, data);

                        console.log('âœ… Marvel API serverless success:', {
                            endpoint,
                            results: data.data?.results?.length || 0,
                            total: data.data?.total || 0
                        });

                        return data;

                    } catch (error) {
                        console.error('âŒ Marvel API Serverless Error:', error);
                        
                        // Fallback to direct call if serverless fails
                        console.log('ðŸ”„ Falling back to direct API call...');
                        try {
                            return await this.callDirect(endpoint, params, cacheKey);
                        } catch (fallbackError) {
                            console.error('âŒ Fallback also failed:', fallbackError);
                            
                            // Show user-friendly error
                            const displayError = error.message.includes('undefined') ?
                                `Error with ${endpoint} endpoint - check console for details` :
                                error.message;

                            showNotification(`âŒ Marvel API Error: ${displayError}`, 5000);
                            return null;
                        }
                    }
                });
            },

            // Legacy method for backward compatibility
            async callLegacy(endpoint, params = {}) {
                const cacheKey = this.getCacheKey(endpoint, params);
                const cachedData = this.getCache(cacheKey);
                if (cachedData) return cachedData;

                return this.queueRequest(async () => {
                    try {
                        // Check if API keys are valid before making request
                        if (this.publicKey === 'your_public_key_here' || this.privateKey === 'your_private_key_here') {
                            throw new Error('Invalid API keys. Please configure valid Marvel API keys.');
                        }

                        const authParams = await this.getAuthParams();
                        const url = new URL(`${this.baseUrl}${endpoint}`);

                        // Add auth and custom parameters
                        Object.entries({...authParams, ...params}).forEach(([key, value]) => {
                            url.searchParams.append(key, value);
                        });

                        console.log('ðŸŒ Marvel API request:', endpoint, params);
                        const response = await this.fetchWithRetry(url);
                        const data = await response.json();

                        if (data.code !== 200) {
                            const errorDetails = data.status || data.message || JSON.stringify(data);
                            throw new Error(`Marvel API Error: ${errorDetails}`);
                        }

                        // Cache successful response
                        this.setCache(cacheKey, data);

                        console.log('âœ… Marvel API success:', {
                            endpoint,
                            results: data.data?.results?.length || 0,
                            total: data.data?.total || 0
                        });

                        return data;

                    } catch (error) {
                        // Ensure we have a valid error message
                        const errorMessage = error.message || 'Unknown error';

                        // Create detailed error log
                        const errorDetails = {
                            endpoint,
                            params,
                            error: errorMessage,
                            timestamp: new Date().toISOString()
                        };

                        console.error('âŒ Marvel API Error:', errorDetails);

                        // Show more informative notification for API errors
                        const displayError = errorMessage.includes('undefined') ?
                            `Error with ${endpoint} endpoint - check console for details` :
                            errorMessage;

                        showNotification(`âŒ Marvel API Error: ${displayError}`, 5000);

                        // Return null for graceful degradation
                        return null;
                    }
                });
            },

            // Get API health status
            async getStatus() {
                try {
                    // Check if Marvel Quiz is enabled from environment variables
                    if (window.ENV?.VITE_MARVEL_QUIZ_ENABLED !== 'true') {
                        return {
                            status: 'disabled',
                            message: 'Marvel Quiz API integration is disabled',
                            details: 'API integration is disabled in environment settings',
                            cacheSize: this.cache.size,
                            queueLength: this.requestQueue.length
                        };
                    }

                    // Check if API keys are valid
                    if (this.publicKey === 'your_public_key_here' || this.privateKey === 'your_private_key_here') {
                        return {
                            status: 'unconfigured',
                            error: 'API keys not configured',
                            cacheSize: this.cache.size,
                            queueLength: this.requestQueue.length
                        };
                    }

                    const startTime = Date.now();
                    const response = await this.call('/characters', { limit: 1 });
                    const responseTime = Date.now() - startTime;

                    return {
                        status: response ? 'online' : 'offline',
                        responseTime,
                        cacheSize: this.cache.size,
                        queueLength: this.requestQueue.length
                    };
                } catch (error) {
                    return {
                        status: 'error',
                        error: error.message,
                        cacheSize: this.cache.size,
                        queueLength: this.requestQueue.length
                    };
                }
            },

            // Clear cache
            clearCache() {
                this.cache.clear();
                console.log('ðŸ—‘ï¸ Marvel API cache cleared');
            }
        };

        // Advanced Question Database with Real Marvel Data Integration
        const QuestionGenerator = {
            // Check if Marvel Quiz is enabled from environment variables
            marvelQuizEnabled: window.ENV?.VITE_MARVEL_QUIZ_ENABLED === 'true',

            // Fallback questions for offline mode
            fallbackQuestions: {
                easy: [
                    {
                        question: "What is the real name of Spider-Man?",
                        answers: ["Peter Parker", "Miles Morales", "Ben Reilly", "Kaine Parker"],
                        correct: 0,
                        character: { name: "Spider-Man", tier: "S", theme: "spider-man" },
                        difficulty: "easy",
                        category: "identity"
                    },
                    {
                        question: "Which metal is Wolverine's skeleton coated with?",
                        answers: ["Vibranium", "Adamantium", "Uru", "Carbonadium"],
                        correct: 1,
                        character: { name: "Wolverine", tier: "S", theme: "wolverine" },
                        difficulty: "easy",
                        category: "powers"
                    },
                    {
                        question: "What is the name of Thor's hammer?",
                        answers: ["Stormbreaker", "Mjolnir", "Gungnir", "Jarnbjorn"],
                        correct: 1,
                        character: { name: "Thor", tier: "S+", theme: "thor" },
                        difficulty: "easy",
                        category: "weapons"
                    },
                    {
                        question: "What is the real name of Iron Man?",
                        answers: ["Tony Stark", "James Rhodes", "Happy Hogan", "Pepper Potts"],
                        correct: 0,
                        character: { name: "Iron Man", tier: "S", theme: "iron-man" },
                        difficulty: "easy",
                        category: "identity"
                    },
                    {
                        question: "What is Captain America's shield made of?",
                        answers: ["Steel", "Adamantium", "Vibranium", "Titanium"],
                        correct: 2,
                        character: { name: "Captain America", tier: "S", theme: "captain-america" },
                        difficulty: "easy",
                        category: "weapons"
                    },
                    {
                        question: "What is the real name of the Hulk?",
                        answers: ["Bruce Banner", "Rick Jones", "General Ross", "Emil Blonsky"],
                        correct: 0,
                        character: { name: "Hulk", tier: "S+", theme: "hulk" },
                        difficulty: "easy",
                        category: "identity"
                    },
                    {
                        question: "Which team do the X-Men belong to?",
                        answers: ["Avengers", "Fantastic Four", "Xavier Institute", "S.H.I.E.L.D."],
                        correct: 2,
                        character: { name: "X-Men", tier: "A", theme: "x-men" },
                        difficulty: "easy",
                        category: "teams"
                    },
                    {
                        question: "What is the name of Spider-Man's aunt?",
                        answers: ["Aunt May", "Aunt Martha", "Aunt Sarah", "Aunt Helen"],
                        correct: 0,
                        character: { name: "Spider-Man", tier: "S", theme: "spider-man" },
                        difficulty: "easy",
                        category: "relationships"
                    },
                    {
                        question: "What color is the Hulk?",
                        answers: ["Blue", "Red", "Green", "Purple"],
                        correct: 2,
                        character: { name: "Hulk", tier: "S+", theme: "hulk" },
                        difficulty: "easy",
                        category: "appearance"
                    },
                    {
                        question: "Who is the leader of the Fantastic Four?",
                        answers: ["The Thing", "Mr. Fantastic", "Human Torch", "Invisible Woman"],
                        correct: 1,
                        character: { name: "Mr. Fantastic", tier: "A", theme: "fantastic-four" },
                        difficulty: "easy",
                        category: "teams"
                    },
                    {
                        question: "What is Black Widow's real name?",
                        answers: ["Natasha Romanoff", "Yelena Belova", "Maria Hill", "Sharon Carter"],
                        correct: 0,
                        character: { name: "Black Widow", tier: "A", theme: "black-widow" },
                        difficulty: "easy",
                        category: "identity"
                    },
                    {
                        question: "Which eye does Nick Fury wear an eyepatch over?",
                        answers: ["Right eye", "Left eye", "Both eyes", "Neither eye"],
                        correct: 1,
                        character: { name: "Nick Fury", tier: "B", theme: "shield" },
                        difficulty: "easy",
                        category: "appearance"
                    },
                    {
                        question: "What is the name of Thor's home realm?",
                        answers: ["Midgard", "Asgard", "Jotunheim", "Alfheim"],
                        correct: 1,
                        character: { name: "Thor", tier: "S+", theme: "thor" },
                        difficulty: "easy",
                        category: "locations"
                    },
                    {
                        question: "Who is known as the 'Merc with a Mouth'?",
                        answers: ["Spider-Man", "Deadpool", "Wolverine", "Punisher"],
                        correct: 1,
                        character: { name: "Deadpool", tier: "A", theme: "deadpool" },
                        difficulty: "easy",
                        category: "nicknames"
                    },
                    {
                        question: "What organization does Nick Fury lead?",
                        answers: ["S.H.I.E.L.D.", "Hydra", "A.I.M.", "The Hand"],
                        correct: 0,
                        character: { name: "Nick Fury", tier: "B", theme: "shield" },
                        difficulty: "easy",
                        category: "organizations"
                    }
                ],
                medium: [
                    {
                        question: "Who created the Infinity Stones?",
                        answers: ["The Celestials", "Cosmic Entities", "The One Above All", "The Living Tribunal"],
                        correct: 1,
                        character: { name: "Infinity", tier: "S+", theme: "cosmic" },
                        difficulty: "medium",
                        category: "cosmic"
                    },
                    {
                        question: "What is the name of the Fantastic Four's headquarters?",
                        answers: ["Avengers Mansion", "Baxter Building", "Stark Tower", "Xavier Institute"],
                        correct: 1,
                        character: { name: "Mr. Fantastic", tier: "A", theme: "fantastic-four" },
                        difficulty: "medium",
                        category: "locations"
                    },
                    {
                        question: "What is the real name of the Winter Soldier?",
                        answers: ["Steve Rogers", "Bucky Barnes", "Sam Wilson", "John Walker"],
                        correct: 1,
                        character: { name: "Winter Soldier", tier: "A", theme: "winter-soldier" },
                        difficulty: "medium",
                        category: "identity"
                    },
                    {
                        question: "Which Infinity Stone is hidden on Vormir?",
                        answers: ["Power Stone", "Reality Stone", "Soul Stone", "Time Stone"],
                        correct: 2,
                        character: { name: "Thanos", tier: "S+", theme: "thanos" },
                        difficulty: "medium",
                        category: "cosmic"
                    },
                    {
                        question: "What is the name of Hawkeye's wife?",
                        answers: ["Laura Barton", "Natasha Romanoff", "Wanda Maximoff", "Pepper Potts"],
                        correct: 0,
                        character: { name: "Hawkeye", tier: "B", theme: "hawkeye" },
                        difficulty: "medium",
                        category: "relationships"
                    },
                    {
                        question: "Who created the android Vision?",
                        answers: ["Tony Stark", "Ultron", "Hank Pym", "Bruce Banner"],
                        correct: 1,
                        character: { name: "Vision", tier: "A", theme: "vision" },
                        difficulty: "medium",
                        category: "origins"
                    },
                    {
                        question: "What is the name of the Wakandan herb that gives Black Panther his powers?",
                        answers: ["Heart-Shaped Herb", "Vibranium Flower", "Panther Root", "Sacred Blossom"],
                        correct: 0,
                        character: { name: "Black Panther", tier: "S", theme: "black-panther" },
                        difficulty: "medium",
                        category: "powers"
                    },
                    {
                        question: "Which villain is known as the 'Mad Titan'?",
                        answers: ["Loki", "Ultron", "Thanos", "Red Skull"],
                        correct: 2,
                        character: { name: "Thanos", tier: "S+", theme: "thanos" },
                        difficulty: "medium",
                        category: "villains"
                    },
                    {
                        question: "What is the name of Doctor Strange's sanctum?",
                        answers: ["Sanctum Sanctorum", "Temple of Vishanti", "Mystic Manor", "Kamar-Taj"],
                        correct: 0,
                        character: { name: "Doctor Strange", tier: "S+", theme: "doctor-strange" },
                        difficulty: "medium",
                        category: "locations"
                    },
                    {
                        question: "Who is the father of Scarlet Witch and Quicksilver?",
                        answers: ["Magneto", "Professor X", "Wolverine", "Cyclops"],
                        correct: 0,
                        character: { name: "Scarlet Witch", tier: "S+", theme: "scarlet-witch" },
                        difficulty: "medium",
                        category: "relationships"
                    },
                    {
                        question: "What is the name of the prison designed to hold supervillains?",
                        answers: ["The Raft", "The Vault", "Ryker's Island", "The Cube"],
                        correct: 0,
                        character: { name: "Various", tier: "B", theme: "prison" },
                        difficulty: "medium",
                        category: "locations"
                    },
                    {
                        question: "Which metal can cut through Wolverine's adamantium claws?",
                        answers: ["Vibranium", "Uru", "Carbonadium", "Anti-Metal"],
                        correct: 3,
                        character: { name: "Wolverine", tier: "S", theme: "wolverine" },
                        difficulty: "medium",
                        category: "powers"
                    },
                    {
                        question: "What is the name of the dimension ruled by Dormammu?",
                        answers: ["Dark Dimension", "Shadow Realm", "Negative Zone", "Limbo"],
                        correct: 0,
                        character: { name: "Dormammu", tier: "S+", theme: "dormammu" },
                        difficulty: "medium",
                        category: "cosmic"
                    },
                    {
                        question: "Who was the first human to become the Ghost Rider?",
                        answers: ["Johnny Blaze", "Danny Ketch", "Carter Slade", "Robbie Reyes"],
                        correct: 2,
                        character: { name: "Ghost Rider", tier: "A", theme: "ghost-rider" },
                        difficulty: "medium",
                        category: "origins"
                    },
                    {
                        question: "What is the name of the Asgardian rainbow bridge?",
                        answers: ["Bifrost", "Heimdall", "Yggdrasil", "Valhalla"],
                        correct: 0,
                        character: { name: "Thor", tier: "S+", theme: "thor" },
                        difficulty: "medium",
                        category: "locations"
                    }
                ],
                hard: [
                    {
                        question: "Who is the current host of the Phoenix Force?",
                        answers: ["Jean Grey", "Rachel Summers", "Hope Summers", "Emma Frost"],
                        correct: 2,
                        character: { name: "Phoenix", tier: "S+", theme: "phoenix" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "What is the name of the cosmic entity that represents the concept of Death?",
                        answers: ["Eternity", "Infinity", "Death", "Oblivion"],
                        correct: 2,
                        character: { name: "Death", tier: "Cosmic", theme: "cosmic" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "Which character wielded the Cosmic Cube to become the Red Skull?",
                        answers: ["Johann Schmidt", "Arnim Zola", "Baron Zemo", "Crossbones"],
                        correct: 0,
                        character: { name: "Red Skull", tier: "A", theme: "red-skull" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "What is the real name of the original Ant-Man?",
                        answers: ["Scott Lang", "Hank Pym", "Eric O'Grady", "Bill Foster"],
                        correct: 1,
                        character: { name: "Ant-Man", tier: "B", theme: "ant-man" },
                        difficulty: "hard",
                        category: "identity"
                    },
                    {
                        question: "Which dimension is home to the Mindless Ones?",
                        answers: ["Dark Dimension", "Negative Zone", "Quantum Realm", "Limbo"],
                        correct: 0,
                        character: { name: "Dormammu", tier: "S+", theme: "dormammu" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "Who was the first person to wear the Iron Man armor after Tony Stark?",
                        answers: ["James Rhodes", "Happy Hogan", "Pepper Potts", "Obadiah Stane"],
                        correct: 0,
                        character: { name: "War Machine", tier: "A", theme: "war-machine" },
                        difficulty: "hard",
                        category: "timeline"
                    },
                    {
                        question: "What is the name of the Shi'ar Imperial Guard's leader?",
                        answers: ["Gladiator", "Corsair", "Lilandra", "Deathbird"],
                        correct: 0,
                        character: { name: "Gladiator", tier: "S", theme: "shiar" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "Which mutant has the ability to absorb and redirect kinetic energy?",
                        answers: ["Gambit", "Bishop", "Cannonball", "Sunspot"],
                        correct: 1,
                        character: { name: "Bishop", tier: "A", theme: "bishop" },
                        difficulty: "hard",
                        category: "powers"
                    },
                    {
                        question: "What is the name of the pocket dimension created by Franklin Richards?",
                        answers: ["Counter-Earth", "Heroes Reborn", "Battleworld", "Negative Zone"],
                        correct: 1,
                        character: { name: "Franklin Richards", tier: "S+", theme: "franklin-richards" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "Who is the Skrull that impersonated Spider-Woman for years?",
                        answers: ["Veranke", "Kl'rt", "Paibok", "Lyja"],
                        correct: 0,
                        character: { name: "Veranke", tier: "A", theme: "skrull" },
                        difficulty: "hard",
                        category: "identity"
                    },
                    {
                        question: "What is the name of the symbiote that bonded with Mac Gargan?",
                        answers: ["Venom", "Carnage", "Toxin", "Anti-Venom"],
                        correct: 0,
                        character: { name: "Venom", tier: "A", theme: "venom" },
                        difficulty: "hard",
                        category: "symbiotes"
                    },
                    {
                        question: "Which Elder of the Universe is obsessed with games and contests?",
                        answers: ["The Collector", "The Grandmaster", "The Gardener", "The Runner"],
                        correct: 1,
                        character: { name: "Grandmaster", tier: "S", theme: "grandmaster" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "What is the name of the artificial intelligence that controls Kree technology?",
                        answers: ["Supreme Intelligence", "MODOK", "Ultron", "Vision"],
                        correct: 0,
                        character: { name: "Supreme Intelligence", tier: "S", theme: "kree" },
                        difficulty: "hard",
                        category: "cosmic"
                    },
                    {
                        question: "Who created the original Human Torch android?",
                        answers: ["Phineas T. Horton", "Reed Richards", "Tony Stark", "Hank Pym"],
                        correct: 0,
                        character: { name: "Human Torch", tier: "A", theme: "human-torch" },
                        difficulty: "hard",
                        category: "origins"
                    },
                    {
                        question: "What is the name of the Asgardian wolf that will devour Odin during Ragnarok?",
                        answers: ["Fenris", "Garm", "Sleipnir", "Jormungandr"],
                        correct: 0,
                        character: { name: "Fenris", tier: "A", theme: "asgard" },
                        difficulty: "hard",
                        category: "mythology"
                    }
                ]
            },

            // AI-Enhanced Question Generation with Adaptive Difficulty
            async generateQuestions(difficulty, count = 10, playerMetrics = null) {
                console.log(`ðŸŽ¯ Generating ${count} ${difficulty} questions with AI-like intelligence...`);

                // Adaptive difficulty adjustment based on player performance
                const adaptedDifficulty = this.getAdaptiveDifficulty(difficulty, playerMetrics);
                console.log(`ðŸ§  Adapted difficulty: ${difficulty} â†’ ${adaptedDifficulty}`);

                // Check if Marvel Quiz is enabled from environment variables
                if (this.marvelQuizEnabled) {
                    try {
                        // Try to fetch real Marvel data with intelligent selection
                        const characters = await this.fetchMarvelCharactersIntelligent(adaptedDifficulty);
                        if (characters && characters.length > 0) {
                            return this.createIntelligentQuestions(characters, adaptedDifficulty, count, playerMetrics);
                        }
                    } catch (error) {
                        console.warn('âš ï¸ API unavailable, using intelligent fallback questions:', error);
                    }
                } else {
                    console.log('â„¹ï¸ Marvel Quiz API integration is disabled, using fallback questions');
                }

                // Enhanced fallback with adaptive selection
                return this.getAdaptiveFallbackQuestions(adaptedDifficulty, count, playerMetrics);
            },

            // Adaptive Difficulty Logic
            getAdaptiveDifficulty(baseDifficulty, playerMetrics) {
                if (!playerMetrics) return baseDifficulty;

                const { accuracy, averageResponseTime, streak, totalQuestions } = playerMetrics;

                // Calculate performance score (0-1)
                const accuracyScore = accuracy / 100;
                const speedScore = Math.max(0, 1 - (averageResponseTime / 15000)); // 15s max
                const streakScore = Math.min(1, streak / 10);
                const performanceScore = (accuracyScore * 0.5 + speedScore * 0.3 + streakScore * 0.2);

                console.log(`ðŸ“Š Performance analysis: accuracy=${accuracyScore.toFixed(2)}, speed=${speedScore.toFixed(2)}, streak=${streakScore.toFixed(2)}, overall=${performanceScore.toFixed(2)}`);

                // Adaptive difficulty mapping
                const difficultyMap = {
                    'easy': ['easy', 'medium', 'hard'],
                    'medium': ['easy', 'medium', 'hard'],
                    'hard': ['medium', 'hard', 'expert']
                };

                const levels = difficultyMap[baseDifficulty] || ['easy', 'medium', 'hard'];

                if (performanceScore >= 0.8) {
                    return levels[Math.min(2, levels.length - 1)]; // Increase difficulty
                } else if (performanceScore <= 0.4) {
                    return levels[0]; // Decrease difficulty
                }

                return baseDifficulty; // Maintain current difficulty
            },

            // Intelligent Marvel Character Fetching
            async fetchMarvelCharactersIntelligent(difficulty) {
                // Difficulty-based character selection criteria
                const difficultyParams = {
                    'easy': { limit: 50, orderBy: 'name', nameStartsWith: ['A', 'B', 'C', 'S'][Math.floor(Math.random() * 4)] },
                    'medium': { limit: 40, orderBy: 'modified', offset: Math.floor(Math.random() * 500) },
                    'hard': { limit: 30, orderBy: '-modified', offset: Math.floor(Math.random() * 1000) },
                    'expert': { limit: 20, orderBy: 'name', offset: Math.floor(Math.random() * 1500) }
                };

                const params = difficultyParams[difficulty] || difficultyParams['medium'];

                console.log(`ðŸŽ¯ Fetching ${difficulty} characters with intelligent selection...`);

                const data = await MARVEL_API.call('/characters', params);
                const characters = data?.data?.results || [];

                return this.filterCharactersByDifficulty(characters, difficulty);
            },

            // Filter characters based on difficulty criteria
            filterCharactersByDifficulty(characters, difficulty) {
                const difficultyFilters = {
                    'easy': (char) => char.comics.available > 10 && char.description.length > 50,
                    'medium': (char) => char.comics.available > 5 && char.series.available > 3,
                    'hard': (char) => char.comics.available > 0 || char.description.length > 20,
                    'expert': (char) => true // Include all characters for expert level
                };

                const filter = difficultyFilters[difficulty] || difficultyFilters['medium'];
                const filtered = characters.filter(filter);

                console.log(`ðŸ” Filtered ${characters.length} â†’ ${filtered.length} characters for ${difficulty} difficulty`);
                return filtered.length > 0 ? filtered : characters; // Fallback to all if none match
            },

            // Legacy method for backward compatibility
            async fetchMarvelCharacters() {
                const data = await MARVEL_API.call('/characters', {
                    limit: 50,
                    orderBy: 'name'
                });

                return data?.data?.results || null;
            },

            // AI-Enhanced Intelligent Question Creation
            createIntelligentQuestions(characters, difficulty, count, playerMetrics) {
                const questions = [];
                const questionTypes = this.getAdaptiveQuestionTypes(difficulty, playerMetrics);

                console.log(`ðŸ§  Creating intelligent questions with types: ${questionTypes.join(', ')}`);

                // Intelligent character selection based on difficulty and variety
                const selectedCharacters = this.selectOptimalCharacters(characters, count, difficulty);

                for (let i = 0; i < count && i < selectedCharacters.length; i++) {
                    const character = selectedCharacters[i];
                    const questionType = this.selectQuestionType(questionTypes, character, playerMetrics);

                    const question = this.generateAdvancedQuestionFromCharacter(character, questionType, difficulty, playerMetrics);
                    if (question) {
                        question.aiGenerated = true;
                        question.complexity = this.calculateQuestionComplexity(question, difficulty);
                        questions.push(question);
                    }
                }

                return questions.length > 0 ? questions : this.getAdaptiveFallbackQuestions(difficulty, count, playerMetrics);
            },

            // Get adaptive question types based on player performance
            getAdaptiveQuestionTypes(difficulty, playerMetrics) {
                const baseTypes = ['identity', 'description', 'comics', 'powers', 'teams', 'enemies'];
                const advancedTypes = ['timeline', 'relationships', 'abilities', 'origins', 'multiverse'];

                if (!playerMetrics) {
                    return difficulty === 'easy' ? baseTypes.slice(0, 3) : baseTypes;
                }

                const { accuracy, averageResponseTime } = playerMetrics;

                if (accuracy > 80 && averageResponseTime < 10000) {
                    return [...baseTypes, ...advancedTypes.slice(0, 2)];
                } else if (accuracy > 60) {
                    return baseTypes;
                } else {
                    return baseTypes.slice(0, 3); // Simpler questions for struggling players
                }
            },

            // Select optimal characters for question generation
            selectOptimalCharacters(characters, count, difficulty) {
                // Sort characters by relevance and difficulty appropriateness
                const scored = characters.map(char => ({
                    character: char,
                    score: this.calculateCharacterScore(char, difficulty)
                })).sort((a, b) => b.score - a.score);

                // Select diverse characters (avoid too many similar ones)
                const selected = [];
                const usedNames = new Set();

                for (const { character } of scored) {
                    if (selected.length >= count) break;

                    const baseName = character.name.split(' ')[0];
                    if (!usedNames.has(baseName)) {
                        selected.push(character);
                        usedNames.add(baseName);
                    }
                }

                return selected;
            },

            // Calculate character relevance score for difficulty
            calculateCharacterScore(character, difficulty) {
                let score = 0;

                // Comics availability score
                const comicsCount = character.comics?.available || 0;
                score += Math.min(comicsCount / 10, 10);

                // Description quality score
                const descLength = character.description?.length || 0;
                score += Math.min(descLength / 50, 5);

                // Series involvement score
                const seriesCount = character.series?.available || 0;
                score += Math.min(seriesCount / 5, 5);

                // Difficulty appropriateness
                const difficultyBonus = {
                    'easy': comicsCount > 20 ? 5 : 0,
                    'medium': comicsCount > 10 ? 3 : 0,
                    'hard': comicsCount > 0 ? 2 : 0,
                    'expert': 1 // All characters are fair game
                };

                score += difficultyBonus[difficulty] || 0;

                return score;
            },

            // Intelligent question type selection
            selectQuestionType(availableTypes, character, playerMetrics) {
                // Weight question types based on character data availability
                const weights = {
                    'identity': character.name ? 1 : 0,
                    'description': character.description ? 1 : 0.3,
                    'comics': character.comics?.available > 0 ? 1 : 0.2,
                    'powers': character.description?.includes('power') ? 1 : 0.5,
                    'teams': character.series?.available > 0 ? 0.8 : 0.3,
                    'enemies': character.comics?.available > 5 ? 0.7 : 0.2
                };

                // Filter available types by weights
                const weightedTypes = availableTypes.filter(type => weights[type] > 0.5);

                return weightedTypes.length > 0
                    ? weightedTypes[Math.floor(Math.random() * weightedTypes.length)]
                    : availableTypes[Math.floor(Math.random() * availableTypes.length)];
            },

            // Legacy method for backward compatibility
            createQuestionsFromAPI(characters, difficulty, count) {
                return this.createIntelligentQuestions(characters, difficulty, count, null);
            },

            // Advanced AI-Enhanced Question Generation
            generateAdvancedQuestionFromCharacter(character, type, difficulty, playerMetrics) {
                if (!character.name) return null;

                const baseQuestion = {
                    character: {
                        name: character.name,
                        tier: this.calculateTier(character),
                        theme: this.getCharacterTheme(character.name),
                        image: character.thumbnail ? `${character.thumbnail.path}.${character.thumbnail.extension}` : null
                    },
                    difficulty: difficulty,
                    category: type,
                    aiEnhanced: true
                };

                switch (type) {
                    case 'identity':
                        return this.generateIdentityQuestion(character, baseQuestion, difficulty);

                    case 'description':
                        return this.generateDescriptionQuestion(character, baseQuestion, difficulty);

                    case 'comics':
                        return this.generateComicsQuestion(character, baseQuestion, difficulty);

                    case 'powers':
                        return this.generatePowersQuestion(character, baseQuestion, difficulty);

                    case 'teams':
                        return this.generateTeamsQuestion(character, baseQuestion, difficulty);

                    case 'enemies':
                        return this.generateEnemiesQuestion(character, baseQuestion, difficulty);

                    case 'timeline':
                        return this.generateTimelineQuestion(character, baseQuestion, difficulty);

                    case 'relationships':
                        return this.generateRelationshipsQuestion(character, baseQuestion, difficulty);
                }

                return null;
            },

            // Enhanced question generators for different types
            generateIdentityQuestion(character, baseQuestion, difficulty) {
                const questions = {
                    'easy': `What is the superhero name of this character?`,
                    'medium': `What is the real name of ${character.name}?`,
                    'hard': `Which alias is NOT associated with ${character.name}?`,
                    'expert': `What is the complete civilian identity of ${character.name}?`
                };

                return {
                    ...baseQuestion,
                    question: questions[difficulty] || questions['medium'],
                    answers: this.generateSmartIdentityAnswers(character, difficulty),
                    correct: 0
                };
            },

            generateDescriptionQuestion(character, baseQuestion, difficulty) {
                if (!character.description) return null;

                const desc = character.description;
                const questions = {
                    'easy': `Which character is described as: "${desc.substring(0, 80)}..."?`,
                    'medium': `Based on this description, identify the character: "${desc.substring(0, 120)}..."?`,
                    'hard': `Which character's origin story includes: "${desc.substring(20, 100)}..."?`,
                    'expert': `Analyze this character description and identify: "${desc.substring(10, 150)}..."?`
                };

                return {
                    ...baseQuestion,
                    question: questions[difficulty] || questions['medium'],
                    answers: this.generateSmartDescriptionAnswers(character, difficulty),
                    correct: 0
                };
            },

            generateComicsQuestion(character, baseQuestion, difficulty) {
                if (!character.comics?.available) return null;

                const count = character.comics.available;
                const questions = {
                    'easy': `Approximately how many comics has ${character.name} appeared in?`,
                    'medium': `${character.name} has appeared in exactly how many comics?`,
                    'hard': `What is the precise comic book appearance count for ${character.name}?`,
                    'expert': `Including variant covers and reprints, ${character.name}'s total comic appearances number:`
                };

                return {
                    ...baseQuestion,
                    question: questions[difficulty] || questions['medium'],
                    answers: this.generateSmartComicsAnswers(count, difficulty),
                    correct: 0
                };
            },

            generatePowersQuestion(character, baseQuestion, difficulty) {
                const powerKeywords = ['power', 'ability', 'strength', 'speed', 'flight', 'telepathy', 'telekinesis'];
                const hasPowerInfo = character.description && powerKeywords.some(keyword =>
                    character.description.toLowerCase().includes(keyword)
                );

                if (!hasPowerInfo) return null;

                const questions = {
                    'easy': `What type of powers does ${character.name} possess?`,
                    'medium': `Which ability is ${character.name} most known for?`,
                    'hard': `What is the source of ${character.name}'s powers?`,
                    'expert': `How did ${character.name} originally acquire their abilities?`
                };

                return {
                    ...baseQuestion,
                    question: questions[difficulty] || questions['medium'],
                    answers: this.generateSmartPowersAnswers(character, difficulty),
                    correct: 0
                };
            },

            // Calculate question complexity for AI scoring
            calculateQuestionComplexity(question, difficulty) {
                let complexity = 1;

                // Base difficulty multiplier
                const difficultyMultipliers = { easy: 1, medium: 1.5, hard: 2, expert: 3 };
                complexity *= difficultyMultipliers[difficulty] || 1;

                // Question type complexity
                const typeComplexity = {
                    identity: 1, description: 1.2, comics: 1.1, powers: 1.3,
                    teams: 1.4, enemies: 1.5, timeline: 2, relationships: 1.8
                };
                complexity *= typeComplexity[question.category] || 1;

                // Character tier bonus
                const tierMultipliers = { 'S+': 1.5, 'S': 1.3, 'A': 1.1, 'B': 1 };
                complexity *= tierMultipliers[question.character.tier] || 1;

                return Math.round(complexity * 10) / 10;
            },

            // Legacy method for backward compatibility
            generateQuestionFromCharacter(character, type, difficulty) {
                return this.generateAdvancedQuestionFromCharacter(character, type, difficulty, null);
            },

            // Helper methods
            calculateTier(character) {
                const comicsCount = character.comics?.available || 0;
                if (comicsCount > 100) return 'S+';
                if (comicsCount > 50) return 'S';
                if (comicsCount > 20) return 'A';
                return 'B';
            },

            getCharacterTheme(name) {
                const themes = {
                    'Spider-Man': 'spider-man',
                    'Iron Man': 'iron-man',
                    'Captain America': 'captain-america',
                    'Thor': 'thor',
                    'Hulk': 'hulk',
                    'Wolverine': 'wolverine'
                };
                return themes[name] || 'default';
            },

            // Smart answer generation methods
            generateSmartIdentityAnswers(character, difficulty) {
                const answers = [character.name];
                const difficultyPools = {
                    'easy': ['Tony Stark', 'Peter Parker', 'Bruce Banner', 'Steve Rogers'],
                    'medium': ['Wade Wilson', 'Matt Murdock', 'Scott Summers', 'Jean Grey'],
                    'hard': ['Victor Von Doom', 'En Sabah Nur', 'Max Eisenhardt', 'Ororo Munroe'],
                    'expert': ['Nathaniel Essex', 'Raven Darkholme', 'Kurt Wagner', 'Piotr Rasputin']
                };

                const pool = difficultyPools[difficulty] || difficultyPools['medium'];

                while (answers.length < 4) {
                    const fake = pool[Math.floor(Math.random() * pool.length)];
                    if (!answers.includes(fake)) {
                        answers.push(fake);
                    }
                }

                return this.shuffleArray(answers);
            },

            generateSmartDescriptionAnswers(character, difficulty) {
                const answers = [character.name];
                const similarCharacters = this.getSimilarCharacters(character, difficulty);

                while (answers.length < 4 && similarCharacters.length > 0) {
                    const similar = similarCharacters.pop();
                    if (!answers.includes(similar)) {
                        answers.push(similar);
                    }
                }

                // Fill remaining slots if needed
                const fallbacks = ['Spider-Man', 'Iron Man', 'Captain America', 'Thor', 'Hulk'];
                while (answers.length < 4) {
                    const fallback = fallbacks[Math.floor(Math.random() * fallbacks.length)];
                    if (!answers.includes(fallback)) {
                        answers.push(fallback);
                    }
                }

                return this.shuffleArray(answers);
            },

            generateSmartComicsAnswers(correctCount, difficulty) {
                const answers = [correctCount.toString()];
                const variance = difficulty === 'easy' ? 50 : difficulty === 'medium' ? 20 : 10;

                for (let i = 0; i < 3; i++) {
                    let fake;
                    do {
                        const offset = Math.floor(Math.random() * variance * 2) - variance;
                        fake = Math.max(1, correctCount + offset).toString();
                    } while (answers.includes(fake));
                    answers.push(fake);
                }

                return this.shuffleArray(answers);
            },

            generateSmartPowersAnswers(character, difficulty) {
                const answers = [this.extractPowerFromDescription(character)];
                const powerTypes = {
                    'easy': ['Super Strength', 'Flight', 'Invisibility', 'Telepathy'],
                    'medium': ['Energy Manipulation', 'Telekinesis', 'Shape-shifting', 'Time Control'],
                    'hard': ['Reality Warping', 'Molecular Manipulation', 'Cosmic Awareness', 'Dimensional Travel'],
                    'expert': ['Omnipotence', 'Abstract Embodiment', 'Universal Control', 'Conceptual Manipulation']
                };

                const pool = powerTypes[difficulty] || powerTypes['medium'];

                while (answers.length < 4) {
                    const fake = pool[Math.floor(Math.random() * pool.length)];
                    if (!answers.includes(fake)) {
                        answers.push(fake);
                    }
                }

                return this.shuffleArray(answers);
            },

            // Helper methods for smart generation
            getSimilarCharacters(character, difficulty) {
                const characterGroups = {
                    'heroes': ['Spider-Man', 'Iron Man', 'Captain America', 'Thor', 'Hulk'],
                    'villains': ['Doctor Doom', 'Magneto', 'Loki', 'Green Goblin', 'Thanos'],
                    'mutants': ['Wolverine', 'Storm', 'Cyclops', 'Jean Grey', 'Professor X'],
                    'cosmic': ['Silver Surfer', 'Galactus', 'Nova', 'Captain Marvel', 'Quasar']
                };

                // Determine character group based on name/description
                let group = 'heroes'; // default
                const name = character.name.toLowerCase();
                const desc = character.description?.toLowerCase() || '';

                if (desc.includes('villain') || desc.includes('evil') || name.includes('doom')) {
                    group = 'villains';
                } else if (desc.includes('mutant') || desc.includes('x-men')) {
                    group = 'mutants';
                } else if (desc.includes('cosmic') || desc.includes('space')) {
                    group = 'cosmic';
                }

                return [...characterGroups[group]].filter(char => char !== character.name);
            },

            extractPowerFromDescription(character) {
                const desc = character.description?.toLowerCase() || '';

                if (desc.includes('strength')) return 'Super Strength';
                if (desc.includes('speed')) return 'Super Speed';
                if (desc.includes('flight') || desc.includes('fly')) return 'Flight';
                if (desc.includes('telepathy') || desc.includes('mind')) return 'Telepathy';
                if (desc.includes('telekinesis')) return 'Telekinesis';
                if (desc.includes('energy')) return 'Energy Manipulation';
                if (desc.includes('magic')) return 'Magic';
                if (desc.includes('healing')) return 'Regeneration';

                return 'Enhanced Abilities'; // fallback
            },

            // Legacy methods for backward compatibility
            generateIdentityAnswers(character) {
                return this.generateSmartIdentityAnswers(character, 'medium');
            },

            generateDescriptionAnswers(character) {
                return this.generateSmartDescriptionAnswers(character, 'medium');
            },

            generateComicsAnswers(actual) {
                return this.generateSmartComicsAnswers(actual, 'medium');
            },

            // Adaptive fallback questions with AI-like selection
            getAdaptiveFallbackQuestions(difficulty, count, playerMetrics) {
                const adaptedDifficulty = this.getAdaptiveDifficulty(difficulty, playerMetrics);

                // Check if adaptedDifficulty exists in fallbackQuestions
                if (!this.fallbackQuestions[adaptedDifficulty]) {
                    // Fallback to medium if the adapted difficulty doesn't exist
                    console.warn(`âš ï¸ Adapted difficulty '${adaptedDifficulty}' not found in fallback questions, using 'medium' instead`);
                    return this.shuffleArray([...this.fallbackQuestions.medium]).slice(0, count);
                }

                const questions = [...this.fallbackQuestions[adaptedDifficulty]];

                // Select questions based on player performance
                const selectedQuestions = this.selectOptimalFallbackQuestions(questions, playerMetrics, count);

                return this.shuffleArray(selectedQuestions).slice(0, count);
            },

            selectOptimalFallbackQuestions(questions, playerMetrics, count) {
                if (!playerMetrics) return questions;

                // Score each question based on player performance
                const scoredQuestions = questions.map(question => ({
                    ...question,
                    adaptiveScore: this.calculateQuestionAdaptiveScore(question, playerMetrics)
                }));

                // Sort by adaptive score and select top questions
                scoredQuestions.sort((a, b) => b.adaptiveScore - a.adaptiveScore);

                return scoredQuestions.slice(0, count);
            },

            calculateQuestionAdaptiveScore(question, playerMetrics) {
                let score = 1;

                // Adjust based on average response time
                if (playerMetrics.averageResponseTime < 10) {
                    // Fast player - prefer harder questions
                    score += question.difficulty === 'hard' ? 0.5 : 0;
                } else if (playerMetrics.averageResponseTime > 20) {
                    // Slower player - prefer easier questions
                    score += question.difficulty === 'easy' ? 0.5 : 0;
                }

                // Adjust based on accuracy
                const accuracy = playerMetrics.correctAnswers / Math.max(1, playerMetrics.totalQuestions);
                if (accuracy > 0.8) {
                    score += question.difficulty === 'hard' ? 0.3 : 0;
                } else if (accuracy < 0.5) {
                    score += question.difficulty === 'easy' ? 0.3 : 0;
                }

                // Prefer variety in question types
                if (playerMetrics.lastQuestionTypes &&
                    !playerMetrics.lastQuestionTypes.includes(question.category)) {
                    score += 0.2;
                }

                return score;
            },

            // Legacy method for backward compatibility
            getFallbackQuestions(difficulty, count) {
                const questions = [...this.fallbackQuestions[difficulty]];
                return this.shuffleArray(questions).slice(0, count);
            },

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        };

        // ===== SCORING SYSTEM =====
        // Advanced scoring logic with performance tracking and achievements
        
        // Advanced Scoring System with AI-like Intelligence
        const ScoringSystem = {
            // Performance tracking for adaptive scoring
            performanceMetrics: {
                averageResponseTime: 0,
                totalQuestions: 0,
                perfectAnswers: 0,
                comboCount: 0,
                maxCombo: 0,
                achievements: new Set(),
                difficultyProgression: 0
            },

            // Achievement definitions
            achievements: {
                SPEED_DEMON: { id: 'speed_demon', name: 'Speed Demon', bonus: 500, condition: (metrics) => metrics.averageResponseTime < 5 },
                PERFECTIONIST: { id: 'perfectionist', name: 'Perfectionist', bonus: 1000, condition: (metrics) => metrics.perfectAnswers >= 5 },
                COMBO_MASTER: { id: 'combo_master', name: 'Combo Master', bonus: 750, condition: (metrics) => metrics.maxCombo >= 10 },
                MARVEL_EXPERT: { id: 'marvel_expert', name: 'Marvel Expert', bonus: 1500, condition: (metrics) => metrics.totalQuestions >= 20 && metrics.averageResponseTime < 10 },
                UNSTOPPABLE: { id: 'unstoppable', name: 'Unstoppable Force', bonus: 2000, condition: (metrics) => metrics.maxCombo >= 15 },
                KNOWLEDGE_SEEKER: { id: 'knowledge_seeker', name: 'Knowledge Seeker', bonus: 300, condition: (metrics) => metrics.totalQuestions >= 10 }
            },

            calculateScore(timeRemaining, difficulty, streak, isCorrect, questionType = 'standard') {
                if (!isCorrect) {
                    this.performanceMetrics.comboCount = 0;
                    return { points: 0, breakdown: { penalty: -50 } };
                }

                // Base scoring components
                const basePoints = 100;
                const difficultyMultipliers = { easy: 1, medium: 1.5, hard: 2.5, expert: 3.5 };
                const difficultyMultiplier = difficultyMultipliers[difficulty] || 1;

                // Advanced time bonus calculation
                const maxTime = 30;
                const timeRatio = timeRemaining / maxTime;
                const timeBonus = Math.floor(timeRatio * 150); // Up to 150 bonus points for speed

                // Enhanced streak system
                const streakBonus = this.calculateStreakBonus(streak);

                // Combo system (consecutive perfect answers)
                this.performanceMetrics.comboCount++;
                this.performanceMetrics.maxCombo = Math.max(this.performanceMetrics.maxCombo, this.performanceMetrics.comboCount);
                const comboMultiplier = this.getComboMultiplier(this.performanceMetrics.comboCount);

                // Question type bonus
                const typeMultipliers = { standard: 1, character: 1.2, comics: 1.3, trivia: 1.1, expert: 1.5 };
                const typeMultiplier = typeMultipliers[questionType] || 1;

                // Perfect answer bonus (answered in < 5 seconds)
                const perfectBonus = timeRemaining > 25 ? 200 : 0;
                if (perfectBonus > 0) this.performanceMetrics.perfectAnswers++;

                // Calculate final score
                const subtotal = (basePoints + timeBonus + streakBonus + perfectBonus) * difficultyMultiplier * typeMultiplier;
                const finalScore = Math.floor(subtotal * comboMultiplier);

                // Update performance metrics
                this.updatePerformanceMetrics(timeRemaining, finalScore);

                // Check for achievements
                const achievementBonus = this.checkAchievements();

                const breakdown = {
                    basePoints,
                    timeBonus,
                    streakBonus,
                    perfectBonus,
                    difficultyMultiplier,
                    comboMultiplier,
                    typeMultiplier,
                    achievementBonus,
                    finalScore: finalScore + achievementBonus
                };

                console.log(`ðŸ“Š Advanced score calculation:`, breakdown);

                return {
                    points: finalScore + achievementBonus,
                    breakdown,
                    achievements: this.getNewAchievements()
                };
            },

            calculateStreakBonus(streak) {
                if (streak < 3) return 0;
                if (streak < 5) return 50;
                if (streak < 10) return 150;
                if (streak < 15) return 300;
                return 500 + (streak - 15) * 50; // Exponential growth for long streaks
            },

            getComboMultiplier(combo) {
                if (combo < 3) return 1;
                if (combo < 5) return 1.1;
                if (combo < 8) return 1.25;
                if (combo < 12) return 1.5;
                if (combo < 20) return 1.75;
                return 2.0; // Maximum 2x multiplier
            },

            updatePerformanceMetrics(responseTime, score) {
                this.performanceMetrics.totalQuestions++;
                const actualResponseTime = 30 - responseTime;

                // Update average response time
                this.performanceMetrics.averageResponseTime =
                    (this.performanceMetrics.averageResponseTime * (this.performanceMetrics.totalQuestions - 1) + actualResponseTime) /
                    this.performanceMetrics.totalQuestions;

                // Adaptive difficulty progression
                if (score > 300) {
                    this.performanceMetrics.difficultyProgression += 0.1;
                } else if (score < 100) {
                    this.performanceMetrics.difficultyProgression -= 0.05;
                }
            },

            checkAchievements() {
                let totalBonus = 0;
                const newAchievements = [];

                Object.values(this.achievements).forEach(achievement => {
                    if (!this.performanceMetrics.achievements.has(achievement.id) &&
                        achievement.condition(this.performanceMetrics)) {
                        this.performanceMetrics.achievements.add(achievement.id);
                        newAchievements.push(achievement);
                        totalBonus += achievement.bonus;

                        // Show achievement notification
                        this.showAchievementNotification(achievement);
                    }
                });

                return totalBonus;
            },

            getNewAchievements() {
                return Array.from(this.performanceMetrics.achievements)
                    .map(id => Object.values(this.achievements).find(a => a.id === id))
                    .filter(Boolean);
            },

            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="achievement-icon">ðŸ†</div>
                    <div class="achievement-content">
                        <div class="achievement-title">Achievement Unlocked!</div>
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-bonus">+${achievement.bonus} points</div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => notification.classList.add('show'), 100);

                // Remove after delay
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => notification.remove(), 500);
                }, 4000);
            },

            getAdaptiveDifficulty() {
                const progression = this.performanceMetrics.difficultyProgression;
                if (progression > 2) return 'expert';
                if (progression > 1) return 'hard';
                if (progression > 0) return 'medium';
                return 'easy';
            },

            getPerformanceMessage(accuracy, totalPoints, difficulty) {
                const combo = this.performanceMetrics.maxCombo;
                const achievements = this.performanceMetrics.achievements.size;

                if (accuracy >= 95 && combo >= 10) {
                    return "ðŸŒŸ LEGENDARY! You've mastered the Marvel Universe with incredible precision!";
                } else if (accuracy >= 90 && totalPoints > 5000) {
                    return "ðŸ† INCREDIBLE! You're a true Marvel Universe expert with exceptional skills!";
                } else if (accuracy >= 85 && combo >= 5) {
                    return "â­ OUTSTANDING! Your Marvel knowledge and speed are truly impressive!";
                } else if (accuracy >= 75) {
                    return "ðŸŽ¯ EXCELLENT! True Believer status achieved! Your Marvel expertise shines!";
                } else if (accuracy >= 60) {
                    return "ðŸ‘ GREAT JOB! You're well on your way to Marvel mastery!";
                } else if (accuracy >= 40) {
                    return "ðŸ“š GOOD EFFORT! Keep exploring the vast Marvel Universe!";
                } else {
                    return "ðŸš€ KEEP GOING! Every hero starts their journey somewhere!";
                }
            },

            getDetailedStats() {
                return {
                    ...this.performanceMetrics,
                    achievementsList: this.getNewAchievements(),
                    suggestedDifficulty: this.getAdaptiveDifficulty()
                };
            },

            reset() {
                this.performanceMetrics = {
                    averageResponseTime: 0,
                    totalQuestions: 0,
                    perfectAnswers: 0,
                    comboCount: 0,
                    maxCombo: 0,
                    achievements: new Set(),
                    difficultyProgression: 0
                };
            }
        };

        // Performance Utilities
        const PerformanceUtils = {
            // Debounce function for performance optimization
            debounce(func, wait, immediate) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        timeout = null;
                        if (!immediate) func(...args);
                    };
                    const callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) func(...args);
                };
            },

            // Throttle function for scroll/resize events
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // Efficient DOM batch updates
            batchDOMUpdates(updates) {
                requestAnimationFrame(() => {
                    updates.forEach(update => update());
                });
            },

            // Lazy loading for images
            lazyLoadImage(img, src) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.src = src;
                            observer.unobserve(entry.target);
                        }
                    });
                });
                observer.observe(img);
            },

            // Memory-efficient particle management
            particlePool: [],
            getParticle() {
                return this.particlePool.pop() || document.createElement('div');
            },
            returnParticle(particle) {
                particle.remove();
                this.particlePool.push(particle);
            }
        };

        // Optimized Particle System
        function initParticles() {
            const particlesContainer = document.getElementById('particles');
            const particleCount = window.innerWidth < 768 ? 20 : 35; // Reduced for performance

            // Use document fragment for batch DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < particleCount; i++) {
                const particle = PerformanceUtils.getParticle();
                particle.className = 'particle';

                // Random size and position
                const size = Math.random() * 4 + 2;
                particle.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    animation-delay: ${Math.random() * 6}s;
                `;

                fragment.appendChild(particle);
            }

            particlesContainer.appendChild(fragment);
        }

        // ===== UI MANAGEMENT =====
        // Functions that control the user interface and display
        
        // Screen Management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');

            // Manage focus for accessibility
            manageFocusForGameState();

            // Announce screen change to screen readers
            const screenNames = {
                'startScreen': 'Start screen - Select difficulty',
                'gameScreen': 'Game screen - Answer questions',
                'resultsScreen': 'Results screen - View your score'
            };

            if (screenNames[screenId]) {
                announceToScreenReader(screenNames[screenId]);
            }
        }

        // Enhanced Difficulty Selection with Accessibility
        function initDifficultySelection() {
            const difficultyOptions = document.querySelectorAll('.difficulty-option');
            const startButton = document.getElementById('startButton');

            difficultyOptions.forEach((option, index) => {
                // Enhanced ARIA attributes
                option.setAttribute('aria-pressed', 'false');
                option.setAttribute('aria-posinset', index + 1);
                option.setAttribute('aria-setsize', difficultyOptions.length);

                option.addEventListener('click', () => selectDifficulty(option));

                // Enhanced keyboard navigation
                option.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        selectDifficulty(option);
                    } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                        e.preventDefault();
                        focusNextDifficulty(index, difficultyOptions.length);
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                        e.preventDefault();
                        focusPreviousDifficulty(index, difficultyOptions.length);
                    } else if (e.key >= '1' && e.key <= '3') {
                        e.preventDefault();
                        const targetIndex = parseInt(e.key) - 1;
                        if (targetIndex < difficultyOptions.length) {
                            selectDifficulty(difficultyOptions[targetIndex]);
                        }
                    }
                });

                // Focus management
                option.addEventListener('focus', () => {
                    announceToScreenReader(`Focused on ${option.dataset.difficulty} difficulty`);
                });
            });

            function selectDifficulty(selectedOption) {
                // Update ARIA states
                difficultyOptions.forEach(opt => {
                    opt.classList.remove('selected');
                    opt.setAttribute('aria-pressed', 'false');
                    opt.setAttribute('aria-selected', 'false');
                });

                selectedOption.classList.add('selected');
                selectedOption.setAttribute('aria-pressed', 'true');
                selectedOption.setAttribute('aria-selected', 'true');

                gameState.difficulty = selectedOption.dataset.difficulty;
                startButton.disabled = false;
                startButton.style.opacity = '1';
                startButton.setAttribute('aria-disabled', 'false');

                // Announce selection to screen readers
                announceToScreenReader(`${selectedOption.dataset.difficulty} difficulty selected. Start button is now enabled.`);

                console.log(`ðŸŽ¯ Difficulty selected: ${gameState.difficulty}`);
            }
        }

        // ===== GAME MECHANICS =====
        // Core functions that control the quiz flow and gameplay
        
        // Quiz Management
        async function startQuiz() {
            const startTime = performance.now();
            console.log('ðŸš€ Starting Ultimate Marvel Quiz...');

            // Reset game state
            gameState = {
                ...gameState,
                currentQuestion: 0,
                score: 0,
                streak: 0,
                maxStreak: 0,
                totalPoints: 0,
                startTime: Date.now(),
                questions: []
            };

            // Show loading and generate questions with performance tracking
            PerformanceUtils.batchDOMUpdates([
                () => showScreen('gameScreen'),
                () => showNotification('ðŸŽ® Generating questions from Marvel Universe...', 3000)
            ]);

            try {
                // Add timeout for question generation
                const questionPromise = Promise.race([
                    QuestionGenerator.generateQuestions(gameState.difficulty, 10),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Question generation timeout')), 5000)
                    )
                ]);

                gameState.questions = await questionPromise;
                const loadTime = performance.now() - startTime;
                console.log(`âœ… Generated ${gameState.questions.length} questions in ${loadTime.toFixed(2)}ms`);

                // Use requestAnimationFrame for smooth transition
                requestAnimationFrame(() => loadQuestion());
            } catch (error) {
                console.error('âŒ Failed to generate questions:', error);
                PerformanceUtils.batchDOMUpdates([
                    () => showNotification('âš ï¸ Failed to load questions. Please try again.', 5000),
                    () => showScreen('startScreen')
                ]);
            }
        }

        // Question Loading
        function loadQuestion() {
            if (gameState.currentQuestion >= gameState.questions.length) {
                endQuiz();
                return;
            }

            const question = gameState.questions[gameState.currentQuestion];
            gameState.questionStartTime = Date.now();
            gameState.timeLeft = 30;
            gameState.isAnswered = false;

            // Batch all DOM updates for better performance
            PerformanceUtils.batchDOMUpdates([
                () => updateGameStats(),
                () => updateQuestionDisplay(question),
                () => createAnswerOptions(question),
                () => {
                    document.getElementById('nextButton').classList.add('hidden');
                    startTimer();
                }
            ]);

            // Load character image asynchronously to avoid blocking
            requestIdleCallback(() => {
                loadCharacterImage(question.character);
            }, { timeout: 200 });

            console.log(`ðŸ“ Loaded question ${gameState.currentQuestion + 1}:`, question.question);
        }

        // Game Statistics Update
        function updateGameStats() {
            document.getElementById('questionCounter').textContent = `${gameState.currentQuestion + 1}/${gameState.questions.length}`;
            document.getElementById('currentScore').textContent = gameState.score;
            document.getElementById('currentStreak').textContent = gameState.streak;
            // Fix NaN values in Bonus card by ensuring we display a valid number
            document.getElementById('bonusPoints').textContent = gameState.streak > 0 ? ScoringSystem.calculateStreakBonus(gameState.streak) : 0;
        }

        // Question Display Update
        function updateQuestionDisplay(question) {
            document.getElementById('questionNumber').textContent = `Question ${gameState.currentQuestion + 1} of ${gameState.questions.length}`;
            document.getElementById('questionText').textContent = question.question;

            const difficultyBadge = document.getElementById('difficultyBadge');
            difficultyBadge.textContent = question.difficulty.charAt(0).toUpperCase() + question.difficulty.slice(1);
            difficultyBadge.className = `difficulty-badge difficulty-${question.difficulty}`;
        }

        // Character Image Loading
        function loadCharacterImage(character) {
            const showcase = document.getElementById('characterShowcase');
            const loading = document.getElementById('characterLoading');

            // Show loading state with performance optimization
            PerformanceUtils.batchDOMUpdates([
                () => {
                    showcase.innerHTML = '';
                    showcase.appendChild(loading);
                }
            ]);

            if (character && character.image) {
                const frame = document.createElement('div');
                frame.className = `character-frame character-theme-${character.theme || 'default'}`;

                const img = document.createElement('img');
                img.className = 'character-image';
                img.alt = `${character.name} character image`;
                img.loading = 'lazy';
                img.decoding = 'async';

                // Optimized image loading with performance tracking
                const imageLoadStart = performance.now();

                img.onload = () => {
                    const loadTime = performance.now() - imageLoadStart;
                    console.log(`ðŸ–¼ï¸ Image loaded in ${loadTime.toFixed(2)}ms`);

                    const overlay = document.createElement('div');
                    overlay.className = 'character-overlay';
                    overlay.innerHTML = `
                        <div class="character-name">${character.name}</div>
                        <div class="character-tier">Tier: ${character.tier}</div>
                    `;

                    // Batch DOM updates for smooth rendering
                    PerformanceUtils.batchDOMUpdates([
                        () => {
                            showcase.innerHTML = '';
                            frame.appendChild(img);
                            frame.appendChild(overlay);
                            showcase.appendChild(frame);
                        }
                    ]);
                };

                img.onerror = () => {
                    console.warn('âš ï¸ Failed to load character image, using fallback');
                    PerformanceUtils.batchDOMUpdates([
                        () => {
                            showcase.innerHTML = `
                                <div class="character-frame">
                                    <div class="character-overlay" style="transform: translateY(0);">
                                        <div class="character-name">${character.name}</div>
                                        <div class="character-tier">Tier: ${character.tier}</div>
                                    </div>
                                </div>
                            `;
                        }
                    ]);
                };

                // Use lazy loading utility for better performance
                PerformanceUtils.lazyLoadImage(img, character.image);
             } else {
                 // No image available - use requestIdleCallback for non-critical updates
                 requestIdleCallback(() => {
                     PerformanceUtils.batchDOMUpdates([
                         () => {
                             showcase.innerHTML = `
                                 <div class="character-frame">
                                     <div class="character-overlay" style="transform: translateY(0);">
                                         <div class="character-name">${character.name}</div>
                                         <div class="character-tier">Tier: ${character.tier}</div>
                                     </div>
                                 </div>
                             `;
                         }
                     ]);
                 }, { timeout: 300 });
             }
         }

         function createAnswerOptions(question) {
             const answersGrid = document.getElementById('answersGrid');
             answersGrid.innerHTML = '';

             question.answers.forEach((answer, index) => {
                 const option = document.createElement('div');
                 option.className = 'answer-option';
                 option.textContent = answer;
                 option.tabIndex = 0;
                 option.setAttribute('role', 'button');
                 option.setAttribute('aria-label', `Answer option ${index + 1} of ${question.answers.length}: ${answer}`);
                 option.setAttribute('aria-describedby', `answer-help-${index}`);
                 option.setAttribute('aria-pressed', 'false');
                 option.id = `answer-option-${index}`;

                 // Add hidden help text for screen readers
                 const helpText = document.createElement('div');
                 helpText.id = `answer-help-${index}`;
                 helpText.className = 'sr-only';
                 helpText.textContent = `Press Enter or Space to select this answer`;
                 option.appendChild(helpText);

                 // Enhanced keyboard navigation
                 option.addEventListener('click', () => selectAnswer(index));
                 option.addEventListener('keydown', (e) => {
                     if (e.key === 'Enter' || e.key === ' ') {
                         e.preventDefault();
                         selectAnswer(index);
                     } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                         e.preventDefault();
                         focusNextAnswer(index, question.answers.length);
                     } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                         e.preventDefault();
                         focusPreviousAnswer(index, question.answers.length);
                     } else if (e.key >= '1' && e.key <= '4' && parseInt(e.key) <= question.answers.length) {
                         e.preventDefault();
                         selectAnswer(parseInt(e.key) - 1);
                     }
                 });

                 // Focus management
                 option.addEventListener('focus', () => {
                     option.setAttribute('aria-describedby', `answer-help-${index} current-focus-help`);
                 });

                 option.addEventListener('blur', () => {
                     option.setAttribute('aria-describedby', `answer-help-${index}`);
                 });

                 answersGrid.appendChild(option);
             });

             // Add current focus help text
             const currentFocusHelp = document.createElement('div');
             currentFocusHelp.id = 'current-focus-help';
             currentFocusHelp.className = 'sr-only';
             currentFocusHelp.setAttribute('aria-live', 'polite');
             currentFocusHelp.textContent = 'Use arrow keys to navigate between answers, or press number keys 1-4 to select directly';
             answersGrid.appendChild(currentFocusHelp);

             // Auto-focus first answer for keyboard users
             if (document.body.classList.contains('keyboard-user')) {
                 setTimeout(() => {
                     const firstOption = answersGrid.querySelector('.answer-option');
                     if (firstOption) firstOption.focus();
                 }, 100);
             }
         }

         // Answer Selection and Scoring
        function selectAnswer(selectedIndex) {
             if (gameState.isAnswered) return;

             gameState.isAnswered = true;
             const question = gameState.questions[gameState.currentQuestion];
             const answerOptions = document.querySelectorAll('.answer-option');
             const isCorrect = selectedIndex === question.correct;
             const responseTime = 30 - gameState.timeLeft;

             // Update ARIA states for accessibility
             answerOptions.forEach((option, index) => {
                 option.setAttribute('aria-disabled', 'true');
                 option.tabIndex = -1;
                 if (index === selectedIndex) {
                     option.setAttribute('aria-pressed', 'true');
                     option.setAttribute('aria-selected', 'true');
                 }
             });

             // Disable all options
             answerOptions.forEach(option => {
                 option.style.pointerEvents = 'none';
                 option.removeEventListener('click', () => {});
             });

             // Show correct/incorrect states with accessibility announcements
             answerOptions.forEach((option, index) => {
                 if (index === question.correct) {
                     option.classList.add('correct');
                     option.setAttribute('aria-label', `Correct answer: ${option.textContent}`);
                 } else if (index === selectedIndex && !isCorrect) {
                     option.classList.add('incorrect');
                     option.setAttribute('aria-label', `Your incorrect answer: ${option.textContent}`);
                 } else {
                     option.setAttribute('aria-label', `Other answer: ${option.textContent}`);
                 }
             });

             // Announce result to screen readers - Fix undefined values
            const correctAnswer = question.answers && question.answers[question.correct] ? question.answers[question.correct] : 'not available';
            const resultMessage = isCorrect ?
                `Correct! The answer was ${correctAnswer}` :
                `Incorrect. The correct answer was ${correctAnswer}`;
             announceToScreenReader(resultMessage);

             // Calculate score using advanced scoring system - Fix NaN values
            const scoreResult = ScoringSystem.calculateScore(
                gameState.timeLeft || 0,
                question.difficulty || 'medium',
                gameState.streak || 0,
                isCorrect,
                responseTime || 0,
                question.category || 'general'
            );

             // Update game state
             if (isCorrect) {
                 gameState.score++;
                 gameState.streak++;
                 gameState.maxStreak = Math.max(gameState.maxStreak, gameState.streak);

                 // Update combo indicator
                 const comboIndicator = document.getElementById('comboIndicator');
                 const comboCount = document.getElementById('comboCount');

                 if (gameState.streak >= 3) {
                     comboIndicator.style.display = 'block';
                     comboCount.textContent = gameState.streak;
                     comboIndicator.style.animation = 'comboPulse 0.5s ease-in-out';

                     setTimeout(() => {
                         comboIndicator.style.animation = '';
                     }, 500);
                 }

                 // Show detailed score breakdown
                 const breakdown = [
                     `Base: ${scoreResult.basePoints}`,
                     `Time: +${scoreResult.timeBonus}`,
                     `Difficulty: x${scoreResult.difficultyMultiplier}`,
                     scoreResult.streakBonus > 0 ? `Streak: +${scoreResult.streakBonus}` : null,
                     scoreResult.comboMultiplier > 1 ? `Combo: x${scoreResult.comboMultiplier}` : null,
                     scoreResult.perfectBonus > 0 ? `Perfect: +${scoreResult.perfectBonus}` : null
                 ].filter(Boolean).join(' | ');

                 showNotification(`âœ… Correct! +${scoreResult.totalPoints} points\n${breakdown}`, 3000);
             } else {
                 gameState.streak = 0;

                 // Hide combo indicator
                 document.getElementById('comboIndicator').style.display = 'none';

                 showNotification('âŒ Incorrect answer', 2000);
             }

             // Ensure totalPoints is never NaN
            gameState.totalPoints += (scoreResult.totalPoints || 0);

             // Check for achievements
             ScoringSystem.checkAchievements(gameState);

             // Stop timer
             clearInterval(gameState.timer);

             // Update UI
             updateGameStats();

             // Show next button and manage focus
             const nextButton = document.getElementById('nextButton');
             nextButton.classList.remove('hidden');

             // Auto-focus next button for keyboard users
             if (document.body.classList.contains('keyboard-user')) {
                 setTimeout(() => nextButton.focus(), 500);
             }
         }

         // Timer Management
        function startTimer() {
             clearInterval(gameState.timer);

             gameState.timer = setInterval(() => {
                 gameState.timeLeft--;
                 document.getElementById('timerValue').textContent = `${gameState.timeLeft}s`;

                 // Update timer bar
                 const percentage = (gameState.timeLeft / 30) * 100;
                 const timerFill = document.getElementById('timerFill');
timerFill.classList.remove('timer-fill-full');
timerFill.style.width = `${percentage}%`;

                 if (gameState.timeLeft <= 0) {
                     clearInterval(gameState.timer);
                     if (!gameState.isAnswered) {
                         selectAnswer(-1); // Auto-select wrong answer
                     }
                 }
             }, 1000);
         }

         // Question Navigation
        function nextQuestion() {
             gameState.currentQuestion++;
             loadQuestion();
         }

         // Quiz Completion
        function endQuiz() {
             const endTime = Date.now();
             const totalTime = Math.floor((endTime - gameState.startTime) / 1000);
             const minutes = Math.floor(totalTime / 60);
             const seconds = totalTime % 60;
             const accuracy = Math.round((gameState.score / gameState.questions.length) * 100);

             // Get detailed performance statistics
             const performanceStats = ScoringSystem.getDetailedStats();

             // Show results screen
             showScreen('resultsScreen');

             // Update basic results
             document.getElementById('finalScore').textContent = `${gameState.score}/${gameState.questions.length}`;
             document.getElementById('correctAnswers').textContent = gameState.score;
             document.getElementById('accuracyPercent').textContent = `${accuracy}%`;
             document.getElementById('totalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
             document.getElementById('totalPoints').textContent = gameState.totalPoints;

             // Set enhanced performance message with achievements
             const message = ScoringSystem.getPerformanceMessage(accuracy, gameState.totalPoints, gameState.difficulty);
             document.getElementById('resultsMessage').innerHTML = `
                 <div>${message}</div>
                 ${performanceStats.achievements.length > 0 ?
                     `<div class="achievements-summary">
                         <h4>ðŸ† Achievements Unlocked (${performanceStats.achievements.length})</h4>
                         ${performanceStats.achievements.map(a => `<span class="achievement-badge">${a}</span>`).join('')}
                     </div>` : ''}
                 <div class="performance-breakdown">
                     <h4>ðŸ“Š Performance Breakdown</h4>
                     <div class="stat-grid">
                         <div>Max Streak: <strong>${gameState.maxStreak}</strong></div>
                         <div>Perfect Answers: <strong>${performanceStats.perfectAnswers}</strong></div>
                         <div>Combo Count: <strong>${performanceStats.comboCount}</strong></div>
                         <div>Avg Response Time: <strong>${performanceStats.averageResponseTime.toFixed(1)}s</strong></div>
                     </div>
                 </div>
             `;

             // Save quiz result for background sync
             const quizResult = {
                 score: gameState.score,
                 totalQuestions: gameState.questions.length,
                 accuracy,
                 totalPoints: gameState.totalPoints,
                 maxStreak: gameState.maxStreak,
                 difficulty: gameState.difficulty,
                 completionTime: totalTime,
                 performanceStats,
                 timestamp: Date.now()
             };

             saveQuizResultOffline(quizResult);

             // Reset scoring system for next quiz
             ScoringSystem.resetPerformanceMetrics();

             console.log('ðŸ Quiz completed:', {
                 score: gameState.score,
                 accuracy,
                 totalPoints: gameState.totalPoints,
                 maxStreak: gameState.maxStreak,
                 performanceStats
             });
         }

         // Quiz Restart
        function restartQuiz() {
             showScreen('startScreen');
             clearInterval(gameState.timer);
         }

         function goHome() {
             window.location.href = '../index.html';
         }

         // Notification System
         // Notification System
        function showNotification(message, duration = 3000) {
             const notification = document.getElementById('notification');
             notification.textContent = message;
             notification.classList.add('show');

             setTimeout(() => {
                 notification.classList.remove('show');
             }, duration);
         }

         // PWA Service Worker Registration
         if ('serviceWorker' in navigator) {
             window.addEventListener('load', async () => {
                 try {
                     console.log('ðŸš€ Registering Service Worker...');
                     const registration = await navigator.serviceWorker.register('./sw.js', {
                         scope: './'
                     });

                     console.log('âœ… Service Worker registered successfully:', registration.scope);

                     // Handle service worker updates
                     registration.addEventListener('updatefound', () => {
                         const newWorker = registration.installing;
                         console.log('ðŸ”„ New Service Worker found, installing...');

                         newWorker.addEventListener('statechange', () => {
                             if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                 console.log('ðŸ“± New content available, reload to update');
                                 showUpdateNotification();
                             }
                         });
                     });

                 } catch (error) {
                     console.error('âŒ Service Worker registration failed:', error);
                 }
             });
         }

         // PWA Install Prompt
         let deferredPrompt;
         window.addEventListener('beforeinstallprompt', (e) => {
             console.log('ðŸ“± PWA install prompt available');
             e.preventDefault();
             deferredPrompt = e;
             showInstallButton();
         });

         function showInstallButton() {
             const installPrompt = document.getElementById('installPrompt');
             installPrompt.classList.add('show');
             installPrompt.addEventListener('click', installPWA);
         }

         async function installPWA() {
             if (deferredPrompt) {
                 console.log('ðŸ“± Showing PWA install prompt');
                 deferredPrompt.prompt();

                 const { outcome } = await deferredPrompt.userChoice;
                 console.log('ðŸ“± PWA install outcome:', outcome);

                 if (outcome === 'accepted') {
                     console.log('âœ… PWA installed successfully');
                     document.getElementById('installPrompt').style.display = 'none';
                 }

                 deferredPrompt = null;
             }
         }

         function showUpdateNotification() {
             showNotification('ðŸ”„ New version available! Reload to update.', 10000);
         }

         // Background Sync for Quiz Results
         async function saveQuizResultOffline(result) {
             if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
                 try {
                     const pendingResults = JSON.parse(localStorage.getItem('pendingQuizResults') || '[]');
                     pendingResults.push({
                         ...result,
                         timestamp: Date.now(),
                         synced: false
                     });
                     localStorage.setItem('pendingQuizResults', JSON.stringify(pendingResults));

                     const registration = await navigator.serviceWorker.ready;
                     await registration.sync.register('quiz-results-sync');

                     console.log('ðŸ“Š Quiz result queued for background sync');
                 } catch (error) {
                     console.error('âŒ Background sync registration failed:', error);
                 }
             }
         }

         // ===== ACCESSIBILITY =====
        // Functions that improve accessibility for all users
        
        // Screen Reader Announcements
        function announceToScreenReader(message) {
             const announcement = document.createElement('div');
             announcement.setAttribute('aria-live', 'polite');
             announcement.setAttribute('aria-atomic', 'true');
             announcement.className = 'sr-only';
             announcement.textContent = message;

             document.body.appendChild(announcement);

             // Remove after announcement
             setTimeout(() => {
                 if (announcement.parentNode) {
                     announcement.parentNode.removeChild(announcement);
                 }
             }, 1000);
         }

         function focusNextAnswer(currentIndex, totalAnswers) {
             const nextIndex = (currentIndex + 1) % totalAnswers;
             const nextOption = document.getElementById(`answer-option-${nextIndex}`);
             if (nextOption) {
                 nextOption.focus();
             }
         }

         function focusPreviousAnswer(currentIndex, totalAnswers) {
             const prevIndex = currentIndex === 0 ? totalAnswers - 1 : currentIndex - 1;
             const prevOption = document.getElementById(`answer-option-${prevIndex}`);
             if (prevOption) {
                 prevOption.focus();
             }
         }

         function focusNextDifficulty(currentIndex, totalOptions) {
             const difficultyOptions = document.querySelectorAll('.difficulty-option');
             const nextIndex = (currentIndex + 1) % totalOptions;
             if (difficultyOptions[nextIndex]) {
                 difficultyOptions[nextIndex].focus();
             }
         }

         function focusPreviousDifficulty(currentIndex, totalOptions) {
             const difficultyOptions = document.querySelectorAll('.difficulty-option');
             const prevIndex = currentIndex === 0 ? totalOptions - 1 : currentIndex - 1;
             if (difficultyOptions[prevIndex]) {
                 difficultyOptions[prevIndex].focus();
             }
         }

         // Enhanced Focus Management
         function manageFocusForGameState() {
             const currentScreen = document.querySelector('.screen.active');
             if (!currentScreen) return;

             // Set appropriate focus based on current screen
             if (currentScreen.id === 'startScreen') {
                 const firstDifficulty = currentScreen.querySelector('.difficulty-option');
                 if (firstDifficulty && document.body.classList.contains('keyboard-user')) {
                     setTimeout(() => firstDifficulty.focus(), 100);
                 }
             } else if (currentScreen.id === 'gameScreen') {
                 const firstAnswer = currentScreen.querySelector('.answer-option');
                 if (firstAnswer && document.body.classList.contains('keyboard-user')) {
                     setTimeout(() => firstAnswer.focus(), 100);
                 }
             } else if (currentScreen.id === 'resultsScreen') {
                 const restartButton = currentScreen.querySelector('button');
                 if (restartButton && document.body.classList.contains('keyboard-user')) {
                     setTimeout(() => restartButton.focus(), 100);
                 }
             }
         }

         // Optimized Event Listeners
         const OptimizedEventListeners = {
             // Throttled resize handler for performance
             handleResize: PerformanceUtils.throttle(() => {
                 const particles = document.querySelectorAll('.particle');
                 particles.forEach(particle => {
                     const x = Math.random() * window.innerWidth;
                     const y = Math.random() * window.innerHeight;
                     particle.style.left = x + 'px';
                     particle.style.top = y + 'px';
                 });
             }, 250),

             // Debounced scroll handler
             handleScroll: PerformanceUtils.debounce(() => {
                 const scrollY = window.scrollY;
                 const particles = document.querySelectorAll('.particle');
                 particles.forEach((particle, index) => {
                     const speed = 0.5 + (index % 3) * 0.2;
                     particle.style.transform = `translateY(${scrollY * speed}px)`;
                 });
             }, 16),

             // Optimized visibility change handler
             handleVisibilityChange: () => {
                 if (document.hidden) {
                     // Pause animations when tab is hidden
                     document.body.style.animationPlayState = 'paused';
                 } else {
                     // Resume animations when tab is visible
                     document.body.style.animationPlayState = 'running';
                 }
             },

             init() {
                 window.addEventListener('resize', this.handleResize, { passive: true });
                 window.addEventListener('scroll', this.handleScroll, { passive: true });
                 document.addEventListener('visibilitychange', this.handleVisibilityChange);
             }
         };

         // ===== INITIALIZATION & EVENT LISTENERS =====
        // Application startup and event binding
        
        // Initialize Application
        document.addEventListener('DOMContentLoaded', async () => {
             const startTime = performance.now();
             console.log('ðŸš€ Ultimate Marvel Universe Quiz - 10x Development Showcase');

             // Initialize optimized event listeners
             OptimizedEventListeners.init();

             // Initialize Marvel API
             MARVEL_API.init();

             // Check API status
             const apiStatus = await MARVEL_API.getStatus();
             console.log('ðŸŒ Marvel API Status:', apiStatus);

             // Initialize particle system
             initParticles();

             // Initialize difficulty selection
             initDifficultySelection();

             // Initialize PWA features
             if ('serviceWorker' in navigator) {
                 console.log('ðŸ“± PWA features available');
             }

             // Show API status notification based on status
             if (apiStatus.status === 'unconfigured') {
                 showNotification('âš ï¸ Marvel API keys not configured - using offline mode', 5000);
                 console.warn('To use the Marvel API, please set valid API keys in the .env file or localStorage');
                 console.info('Get your Marvel API keys at: https://developer.marvel.com/account');
             } else if (apiStatus.status === 'offline' || apiStatus.status === 'error') {
                 showNotification(`âš ï¸ Marvel API unavailable - using offline mode (${apiStatus.error || 'Unknown error'})`, 5000);
             } else {
                 showNotification(`âœ… Marvel API online (${apiStatus.responseTime || 'unknown'}ms)`, 3000);
             }

             const initTime = performance.now() - startTime;
             console.log(`âœ… Application initialized in ${Math.round(initTime)}ms!`);
         });

         // Performance monitoring
         window.addEventListener('load', () => {
             if ('performance' in window) {
                 const loadTime = performance.now();
                 console.log(`âš¡ Page loaded in ${Math.round(loadTime)}ms`);

                 if (loadTime < 1000) {
                     console.log('ðŸš€ Sub-second load time achieved!');
                 }
             }
         });

         console.log('ðŸŽ® Ultimate Marvel Universe Quiz loaded - Ready for 10x performance!');

        // GitHub Badge functionality
        function hideBadge() {
            const badge = document.getElementById('githubBadge');
            if (badge) {
                badge.style.transform = 'translateX(100%)';
                badge.style.opacity = '0';
                setTimeout(() => {
                    badge.style.display = 'none';
                }, 300);
                localStorage.setItem('githubBadgeHidden', 'true');
            }
        }

        // Show badge on load if not previously hidden
        document.addEventListener('DOMContentLoaded', () => {
            const badge = document.getElementById('githubBadge');
            const isHidden = localStorage.getItem('githubBadgeHidden');
            
            if (badge && !isHidden) {
                setTimeout(() => {
                    badge.classList.add('show');
                }, 2000); // Show after 2 seconds
            } else if (badge && isHidden) {
                badge.style.display = 'none';
            }
        });
     </script>

     <style>
        /* GitHub Deployment Badge Styles */
        .github-deployment-badge {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2), 0 0 20px rgba(255, 255, 255, 0.1);
            z-index: 1000;
            color: rgba(255, 255, 255, 0.9);
            font-family: var(--font-primary);
            font-size: 12px;
            line-height: 1.4;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: default;
        }

        .github-deployment-badge.show {
            transform: translateX(0);
            opacity: 1;
        }

        .github-deployment-badge:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25), 0 0 30px rgba(255, 255, 255, 0.15);
            transform: translateX(0) translateY(-2px);
        }

        .badge-icon {
            flex-shrink: 0;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .github-deployment-badge:hover .badge-icon {
            opacity: 1;
        }

        .badge-content {
            flex: 1;
            min-width: 0;
        }

        .badge-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
            color: rgba(255, 255, 255, 0.95);
        }

        .badge-description {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.3;
        }

        .badge-close {
            flex-shrink: 0;
            padding: 4px;
            border-radius: 6px;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s ease;
            margin-left: 4px;
        }

        .badge-close:hover,
        .badge-close:focus {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }

        .badge-close:focus {
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .github-deployment-badge {
                bottom: 15px;
                right: 15px;
                max-width: 250px;
                padding: 10px 12px;
                font-size: 11px;
            }

            .badge-title {
                font-size: 12px;
            }

            .badge-description {
                font-size: 10px;
            }
        }

        @media (max-width: 480px) {
            .github-deployment-badge {
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                padding: 8px 10px;
            }
        }

        /* Ensure badge doesn't interfere with game UI */
        @media (max-height: 600px) {
            .github-deployment-badge {
                bottom: 10px;
                transform: scale(0.9) translateX(100%);
            }

            .github-deployment-badge.show {
                transform: scale(0.9) translateX(0);
            }

            .github-deployment-badge:hover {
                transform: scale(0.9) translateX(0) translateY(-2px);
            }
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            .github-deployment-badge {
                transition: opacity 0.2s ease;
                transform: translateX(0) !important;
            }

            .github-deployment-badge:hover {
                transform: translateX(0) !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .github-deployment-badge {
                background: rgba(0, 0, 0, 0.8);
                border-color: rgba(255, 255, 255, 0.8);
                color: white;
            }
        }
     </style>
 </body>
 </html>
